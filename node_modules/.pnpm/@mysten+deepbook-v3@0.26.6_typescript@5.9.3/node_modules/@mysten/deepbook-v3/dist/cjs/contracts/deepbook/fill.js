"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var fill_exports = {};
__export(fill_exports, {
  Fill: () => Fill,
  balanceManagerId: () => balanceManagerId,
  baseQuantity: () => baseQuantity,
  completed: () => completed,
  executionPrice: () => executionPrice,
  expired: () => expired,
  makerClientOrderId: () => makerClientOrderId,
  makerDeepPrice: () => makerDeepPrice,
  makerEpoch: () => makerEpoch,
  makerFee: () => makerFee,
  makerFeeIsDeep: () => makerFeeIsDeep,
  makerOrderId: () => makerOrderId,
  originalMakerQuantity: () => originalMakerQuantity,
  quoteQuantity: () => quoteQuantity,
  takerFee: () => takerFee,
  takerFeeIsDeep: () => takerFeeIsDeep,
  takerIsBid: () => takerIsBid
});
module.exports = __toCommonJS(fill_exports);
var import_utils = require("../utils/index.js");
var import_bcs = require("@mysten/sui/bcs");
var deep_price = __toESM(require("./deep_price.js"));
const $moduleName = "@deepbook/core::fill";
const Fill = new import_utils.MoveStruct({
  name: `${$moduleName}::Fill`,
  fields: {
    maker_order_id: import_bcs.bcs.u128(),
    maker_client_order_id: import_bcs.bcs.u64(),
    execution_price: import_bcs.bcs.u64(),
    balance_manager_id: import_bcs.bcs.Address,
    expired: import_bcs.bcs.bool(),
    completed: import_bcs.bcs.bool(),
    original_maker_quantity: import_bcs.bcs.u64(),
    base_quantity: import_bcs.bcs.u64(),
    quote_quantity: import_bcs.bcs.u64(),
    taker_is_bid: import_bcs.bcs.bool(),
    maker_epoch: import_bcs.bcs.u64(),
    maker_deep_price: deep_price.OrderDeepPrice,
    taker_fee: import_bcs.bcs.u64(),
    taker_fee_is_deep: import_bcs.bcs.bool(),
    maker_fee: import_bcs.bcs.u64(),
    maker_fee_is_deep: import_bcs.bcs.bool()
  }
});
function makerOrderId(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "maker_order_id",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function makerClientOrderId(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "maker_client_order_id",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function executionPrice(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "execution_price",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function balanceManagerId(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "balance_manager_id",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function expired(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "expired",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function completed(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "completed",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function originalMakerQuantity(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "original_maker_quantity",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function baseQuantity(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "base_quantity",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function takerIsBid(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "taker_is_bid",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function quoteQuantity(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "quote_quantity",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function makerEpoch(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "maker_epoch",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function makerDeepPrice(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "maker_deep_price",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function takerFee(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "taker_fee",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function takerFeeIsDeep(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "taker_fee_is_deep",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function makerFee(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "maker_fee",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function makerFeeIsDeep(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::fill::Fill`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "fill",
    function: "maker_fee_is_deep",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
//# sourceMappingURL=fill.js.map
