{
  "version": 3,
  "sources": ["../../../../src/contracts/deepbook/math.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { Transaction } from '@mysten/sui/transactions';\nimport { normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nexport interface MulArguments {\n\tx: RawTransactionArgument<number | bigint>;\n\ty: RawTransactionArgument<number | bigint>;\n}\nexport interface MulOptions {\n\tpackage?: string;\n\targuments:\n\t\t| MulArguments\n\t\t| [x: RawTransactionArgument<number | bigint>, y: RawTransactionArgument<number | bigint>];\n}\n/** Multiply two floating numbers. This function will round down the result. */\nexport function mul(options: MulOptions) {\n\tconst packageAddress = options.package ?? '@deepbook/core';\n\tconst argumentsTypes = ['u64', 'u64'] satisfies string[];\n\tconst parameterNames = ['x', 'y'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'math',\n\t\t\tfunction: 'mul',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface MulU128Arguments {\n\tx: RawTransactionArgument<number | bigint>;\n\ty: RawTransactionArgument<number | bigint>;\n}\nexport interface MulU128Options {\n\tpackage?: string;\n\targuments:\n\t\t| MulU128Arguments\n\t\t| [x: RawTransactionArgument<number | bigint>, y: RawTransactionArgument<number | bigint>];\n}\nexport function mulU128(options: MulU128Options) {\n\tconst packageAddress = options.package ?? '@deepbook/core';\n\tconst argumentsTypes = ['u128', 'u128'] satisfies string[];\n\tconst parameterNames = ['x', 'y'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'math',\n\t\t\tfunction: 'mul_u128',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface MulRoundUpArguments {\n\tx: RawTransactionArgument<number | bigint>;\n\ty: RawTransactionArgument<number | bigint>;\n}\nexport interface MulRoundUpOptions {\n\tpackage?: string;\n\targuments:\n\t\t| MulRoundUpArguments\n\t\t| [x: RawTransactionArgument<number | bigint>, y: RawTransactionArgument<number | bigint>];\n}\n/** Multiply two floating numbers. This function will round up the result. */\nexport function mulRoundUp(options: MulRoundUpOptions) {\n\tconst packageAddress = options.package ?? '@deepbook/core';\n\tconst argumentsTypes = ['u64', 'u64'] satisfies string[];\n\tconst parameterNames = ['x', 'y'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'math',\n\t\t\tfunction: 'mul_round_up',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DivArguments {\n\tx: RawTransactionArgument<number | bigint>;\n\ty: RawTransactionArgument<number | bigint>;\n}\nexport interface DivOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DivArguments\n\t\t| [x: RawTransactionArgument<number | bigint>, y: RawTransactionArgument<number | bigint>];\n}\n/** Divide two floating numbers. This function will round down the result. */\nexport function div(options: DivOptions) {\n\tconst packageAddress = options.package ?? '@deepbook/core';\n\tconst argumentsTypes = ['u64', 'u64'] satisfies string[];\n\tconst parameterNames = ['x', 'y'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'math',\n\t\t\tfunction: 'div',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DivU128Arguments {\n\tx: RawTransactionArgument<number | bigint>;\n\ty: RawTransactionArgument<number | bigint>;\n}\nexport interface DivU128Options {\n\tpackage?: string;\n\targuments:\n\t\t| DivU128Arguments\n\t\t| [x: RawTransactionArgument<number | bigint>, y: RawTransactionArgument<number | bigint>];\n}\nexport function divU128(options: DivU128Options) {\n\tconst packageAddress = options.package ?? '@deepbook/core';\n\tconst argumentsTypes = ['u128', 'u128'] satisfies string[];\n\tconst parameterNames = ['x', 'y'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'math',\n\t\t\tfunction: 'div_u128',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DivRoundUpArguments {\n\tx: RawTransactionArgument<number | bigint>;\n\ty: RawTransactionArgument<number | bigint>;\n}\nexport interface DivRoundUpOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DivRoundUpArguments\n\t\t| [x: RawTransactionArgument<number | bigint>, y: RawTransactionArgument<number | bigint>];\n}\n/** Divide two floating numbers. This function will round up the result. */\nexport function divRoundUp(options: DivRoundUpOptions) {\n\tconst packageAddress = options.package ?? '@deepbook/core';\n\tconst argumentsTypes = ['u64', 'u64'] satisfies string[];\n\tconst parameterNames = ['x', 'y'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'math',\n\t\t\tfunction: 'div_round_up',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface MedianArguments {\n\tv: RawTransactionArgument<number | bigint[]>;\n}\nexport interface MedianOptions {\n\tpackage?: string;\n\targuments: MedianArguments | [v: RawTransactionArgument<number | bigint[]>];\n}\n/** given a vector of u64, return the median */\nexport function median(options: MedianOptions) {\n\tconst packageAddress = options.package ?? '@deepbook/core';\n\tconst argumentsTypes = ['vector<u128>'] satisfies string[];\n\tconst parameterNames = ['v'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'math',\n\t\t\tfunction: 'median',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SqrtArguments {\n\tx: RawTransactionArgument<number | bigint>;\n\tprecision: RawTransactionArgument<number | bigint>;\n}\nexport interface SqrtOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SqrtArguments\n\t\t| [\n\t\t\t\tx: RawTransactionArgument<number | bigint>,\n\t\t\t\tprecision: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/**\n * Computes the integer square root of a scaled u64 value, assuming the original\n * value is scaled by precision. The result will be in the same floating-point\n * representation.\n */\nexport function sqrt(options: SqrtOptions) {\n\tconst packageAddress = options.package ?? '@deepbook/core';\n\tconst argumentsTypes = ['u64', 'u64'] satisfies string[];\n\tconst parameterNames = ['x', 'precision'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'math',\n\t\t\tfunction: 'sqrt',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface IsPowerOfTenArguments {\n\tn: RawTransactionArgument<number | bigint>;\n}\nexport interface IsPowerOfTenOptions {\n\tpackage?: string;\n\targuments: IsPowerOfTenArguments | [n: RawTransactionArgument<number | bigint>];\n}\nexport function isPowerOfTen(options: IsPowerOfTenOptions) {\n\tconst packageAddress = options.package ?? '@deepbook/core';\n\tconst argumentsTypes = ['u64'] satisfies string[];\n\tconst parameterNames = ['n'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'math',\n\t\t\tfunction: 'is_power_of_ten',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],
  "mappings": "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",
  "names": []
}
