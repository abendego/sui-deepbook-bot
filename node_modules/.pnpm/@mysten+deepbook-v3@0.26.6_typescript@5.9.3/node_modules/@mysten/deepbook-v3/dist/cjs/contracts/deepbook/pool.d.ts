/** Public-facing interface for the package. */
import { MoveStruct } from '../utils/index.js';
import type { RawTransactionArgument } from '../utils/index.js';
import type { BcsType } from '@mysten/sui/bcs';
import type { Transaction } from '@mysten/sui/transactions';
export declare const Pool: MoveStruct<{
    id: MoveStruct<{
        id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    inner: MoveStruct<{
        id: MoveStruct<{
            id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        version: BcsType<string, string | number | bigint, "u64">;
    }, "0x2::versioned::Versioned">;
}, "@deepbook/core::pool::Pool">;
export declare const PoolInner: MoveStruct<{
    allowed_versions: MoveStruct<{
        contents: BcsType<string[], Iterable<string | number | bigint> & {
            length: number;
        }, string>;
    }, "0x2::vec_set::VecSet<u64>">;
    pool_id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    book: MoveStruct<{
        tick_size: BcsType<string, string | number | bigint, "u64">;
        lot_size: BcsType<string, string | number | bigint, "u64">;
        min_size: BcsType<string, string | number | bigint, "u64">;
        bids: MoveStruct<{
            id: MoveStruct<{
                id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
            }, "0x2::object::UID">;
            depth: BcsType<number, number, "u8">;
            length: BcsType<string, string | number | bigint, "u64">;
            max_slice_size: BcsType<string, string | number | bigint, "u64">;
            max_fan_out: BcsType<string, string | number | bigint, "u64">;
            root_id: BcsType<string, string | number | bigint, "u64">;
            last_id: BcsType<string, string | number | bigint, "u64">;
        }, "@deepbook/core::big_vector::BigVector">;
        asks: MoveStruct<{
            id: MoveStruct<{
                id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
            }, "0x2::object::UID">;
            depth: BcsType<number, number, "u8">;
            length: BcsType<string, string | number | bigint, "u64">;
            max_slice_size: BcsType<string, string | number | bigint, "u64">;
            max_fan_out: BcsType<string, string | number | bigint, "u64">;
            root_id: BcsType<string, string | number | bigint, "u64">;
            last_id: BcsType<string, string | number | bigint, "u64">;
        }, "@deepbook/core::big_vector::BigVector">;
        next_bid_order_id: BcsType<string, string | number | bigint, "u64">;
        next_ask_order_id: BcsType<string, string | number | bigint, "u64">;
    }, "@deepbook/core::book::Book">;
    state: MoveStruct<{
        accounts: MoveStruct<{
            id: MoveStruct<{
                id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
            }, "0x2::object::UID">;
            size: BcsType<string, string | number | bigint, "u64">;
        }, "0x2::table::Table">;
        history: MoveStruct<{
            epoch: BcsType<string, string | number | bigint, "u64">;
            epoch_created: BcsType<string, string | number | bigint, "u64">;
            volumes: MoveStruct<{
                total_volume: BcsType<string, string | number | bigint, "u128">;
                total_staked_volume: BcsType<string, string | number | bigint, "u128">;
                total_fees_collected: MoveStruct<{
                    base: BcsType<string, string | number | bigint, "u64">;
                    quote: BcsType<string, string | number | bigint, "u64">;
                    deep: BcsType<string, string | number | bigint, "u64">;
                }, "@deepbook/core::balances::Balances">;
                historic_median: BcsType<string, string | number | bigint, "u128">;
                trade_params: MoveStruct<{
                    taker_fee: BcsType<string, string | number | bigint, "u64">;
                    maker_fee: BcsType<string, string | number | bigint, "u64">;
                    stake_required: BcsType<string, string | number | bigint, "u64">;
                }, "@deepbook/core::trade_params::TradeParams">;
            }, "@deepbook/core::history::Volumes">;
            historic_volumes: MoveStruct<{
                id: MoveStruct<{
                    id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
                }, "0x2::object::UID">;
                size: BcsType<string, string | number | bigint, "u64">;
            }, "0x2::table::Table">;
            balance_to_burn: BcsType<string, string | number | bigint, "u64">;
        }, "@deepbook/core::history::History">;
        governance: MoveStruct<{
            epoch: BcsType<string, string | number | bigint, "u64">;
            whitelisted: BcsType<boolean, boolean, "bool">;
            stable: BcsType<boolean, boolean, "bool">;
            proposals: MoveStruct<{
                contents: BcsType<{
                    key: string;
                    value: {
                        taker_fee: string;
                        maker_fee: string;
                        stake_required: string;
                        votes: string;
                    };
                }[], Iterable<{
                    key: string | Uint8Array<ArrayBufferLike>;
                    value: {
                        taker_fee: string | number | bigint;
                        maker_fee: string | number | bigint;
                        stake_required: string | number | bigint;
                        votes: string | number | bigint;
                    };
                }> & {
                    length: number;
                }, string>;
            }, "0x2::vec_map::VecMap<bytes[32], @deepbook/core::governance::Proposal>">;
            trade_params: MoveStruct<{
                taker_fee: BcsType<string, string | number | bigint, "u64">;
                maker_fee: BcsType<string, string | number | bigint, "u64">;
                stake_required: BcsType<string, string | number | bigint, "u64">;
            }, "@deepbook/core::trade_params::TradeParams">;
            next_trade_params: MoveStruct<{
                taker_fee: BcsType<string, string | number | bigint, "u64">;
                maker_fee: BcsType<string, string | number | bigint, "u64">;
                stake_required: BcsType<string, string | number | bigint, "u64">;
            }, "@deepbook/core::trade_params::TradeParams">;
            voting_power: BcsType<string, string | number | bigint, "u64">;
            quorum: BcsType<string, string | number | bigint, "u64">;
        }, "@deepbook/core::governance::Governance">;
    }, "@deepbook/core::state::State">;
    vault: MoveStruct<{
        base_balance: MoveStruct<{
            value: BcsType<string, string | number | bigint, "u64">;
        }, "0x2::balance::Balance">;
        quote_balance: MoveStruct<{
            value: BcsType<string, string | number | bigint, "u64">;
        }, "0x2::balance::Balance">;
        deep_balance: MoveStruct<{
            value: BcsType<string, string | number | bigint, "u64">;
        }, "0x2::balance::Balance">;
    }, "@deepbook/core::vault::Vault">;
    deep_price: MoveStruct<{
        base_prices: BcsType<{
            conversion_rate: string;
            timestamp: string;
        }[], Iterable<{
            conversion_rate: string | number | bigint;
            timestamp: string | number | bigint;
        }> & {
            length: number;
        }, string>;
        cumulative_base: BcsType<string, string | number | bigint, "u64">;
        quote_prices: BcsType<{
            conversion_rate: string;
            timestamp: string;
        }[], Iterable<{
            conversion_rate: string | number | bigint;
            timestamp: string | number | bigint;
        }> & {
            length: number;
        }, string>;
        cumulative_quote: BcsType<string, string | number | bigint, "u64">;
    }, "@deepbook/core::deep_price::DeepPrice">;
    registered_pool: BcsType<boolean, boolean, "bool">;
}, "@deepbook/core::pool::PoolInner">;
export declare const PoolCreated: MoveStruct<{
    pool_id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    taker_fee: BcsType<string, string | number | bigint, "u64">;
    maker_fee: BcsType<string, string | number | bigint, "u64">;
    tick_size: BcsType<string, string | number | bigint, "u64">;
    lot_size: BcsType<string, string | number | bigint, "u64">;
    min_size: BcsType<string, string | number | bigint, "u64">;
    whitelisted_pool: BcsType<boolean, boolean, "bool">;
    treasury_address: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@deepbook/core::pool::PoolCreated">;
export declare const BookParamsUpdated: MoveStruct<{
    pool_id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    tick_size: BcsType<string, string | number | bigint, "u64">;
    lot_size: BcsType<string, string | number | bigint, "u64">;
    min_size: BcsType<string, string | number | bigint, "u64">;
    timestamp: BcsType<string, string | number | bigint, "u64">;
}, "@deepbook/core::pool::BookParamsUpdated">;
export declare const DeepBurned: MoveStruct<{
    pool_id: BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    deep_burned: BcsType<string, string | number | bigint, "u64">;
}, "@deepbook/core::pool::DeepBurned">;
export declare const AppKey: MoveStruct<{
    dummy_field: BcsType<boolean, boolean, "bool">;
}, "@deepbook/core::pool::AppKey">;
export declare const MarginTradingKey: MoveStruct<{
    dummy_field: BcsType<boolean, boolean, "bool">;
}, "@deepbook/core::pool::MarginTradingKey">;
export interface CreatePermissionlessPoolArguments {
    registry: RawTransactionArgument<string>;
    tickSize: RawTransactionArgument<number | bigint>;
    lotSize: RawTransactionArgument<number | bigint>;
    minSize: RawTransactionArgument<number | bigint>;
    creationFee: RawTransactionArgument<string>;
}
export interface CreatePermissionlessPoolOptions {
    package?: string;
    arguments: CreatePermissionlessPoolArguments | [
        registry: RawTransactionArgument<string>,
        tickSize: RawTransactionArgument<number | bigint>,
        lotSize: RawTransactionArgument<number | bigint>,
        minSize: RawTransactionArgument<number | bigint>,
        creationFee: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/**
 * Create a new pool. The pool is registered in the registry. Checks are performed
 * to ensure the tick size, lot size, and min size are valid. The creation fee is
 * transferred to the treasury address. Returns the id of the pool created
 */
export declare function createPermissionlessPool(options: CreatePermissionlessPoolOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface PlaceLimitOrderArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
    clientOrderId: RawTransactionArgument<number | bigint>;
    orderType: RawTransactionArgument<number>;
    selfMatchingOption: RawTransactionArgument<number>;
    price: RawTransactionArgument<number | bigint>;
    quantity: RawTransactionArgument<number | bigint>;
    isBid: RawTransactionArgument<boolean>;
    payWithDeep: RawTransactionArgument<boolean>;
    expireTimestamp: RawTransactionArgument<number | bigint>;
}
export interface PlaceLimitOrderOptions {
    package?: string;
    arguments: PlaceLimitOrderArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>,
        clientOrderId: RawTransactionArgument<number | bigint>,
        orderType: RawTransactionArgument<number>,
        selfMatchingOption: RawTransactionArgument<number>,
        price: RawTransactionArgument<number | bigint>,
        quantity: RawTransactionArgument<number | bigint>,
        isBid: RawTransactionArgument<boolean>,
        payWithDeep: RawTransactionArgument<boolean>,
        expireTimestamp: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Place a limit order. Quantity is in base asset terms. For current version
 * pay_with_deep must be true, so the fee will be paid with DEEP tokens.
 */
export declare function placeLimitOrder(options: PlaceLimitOrderOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface PlaceMarketOrderArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
    clientOrderId: RawTransactionArgument<number | bigint>;
    selfMatchingOption: RawTransactionArgument<number>;
    quantity: RawTransactionArgument<number | bigint>;
    isBid: RawTransactionArgument<boolean>;
    payWithDeep: RawTransactionArgument<boolean>;
}
export interface PlaceMarketOrderOptions {
    package?: string;
    arguments: PlaceMarketOrderArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>,
        clientOrderId: RawTransactionArgument<number | bigint>,
        selfMatchingOption: RawTransactionArgument<number>,
        quantity: RawTransactionArgument<number | bigint>,
        isBid: RawTransactionArgument<boolean>,
        payWithDeep: RawTransactionArgument<boolean>
    ];
    typeArguments: [string, string];
}
/**
 * Place a market order. Quantity is in base asset terms. Calls place_limit_order
 * with a price of MAX_PRICE for bids and MIN_PRICE for asks. Any quantity not
 * filled is cancelled.
 */
export declare function placeMarketOrder(options: PlaceMarketOrderOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SwapExactBaseForQuoteArguments {
    self: RawTransactionArgument<string>;
    baseIn: RawTransactionArgument<string>;
    deepIn: RawTransactionArgument<string>;
    minQuoteOut: RawTransactionArgument<number | bigint>;
}
export interface SwapExactBaseForQuoteOptions {
    package?: string;
    arguments: SwapExactBaseForQuoteArguments | [
        self: RawTransactionArgument<string>,
        baseIn: RawTransactionArgument<string>,
        deepIn: RawTransactionArgument<string>,
        minQuoteOut: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Swap exact base quantity without needing a `balance_manager`. DEEP quantity can
 * be overestimated. Returns three `Coin` objects: base, quote, and deep. Some base
 * quantity may be left over, if the input quantity is not divisible by lot size.
 */
export declare function swapExactBaseForQuote(options: SwapExactBaseForQuoteOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SwapExactQuoteForBaseArguments {
    self: RawTransactionArgument<string>;
    quoteIn: RawTransactionArgument<string>;
    deepIn: RawTransactionArgument<string>;
    minBaseOut: RawTransactionArgument<number | bigint>;
}
export interface SwapExactQuoteForBaseOptions {
    package?: string;
    arguments: SwapExactQuoteForBaseArguments | [
        self: RawTransactionArgument<string>,
        quoteIn: RawTransactionArgument<string>,
        deepIn: RawTransactionArgument<string>,
        minBaseOut: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Swap exact quote quantity without needing a `balance_manager`. DEEP quantity can
 * be overestimated. Returns three `Coin` objects: base, quote, and deep. Some
 * quote quantity may be left over if the input quantity is not divisible by lot
 * size.
 */
export declare function swapExactQuoteForBase(options: SwapExactQuoteForBaseOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SwapExactQuantityArguments {
    self: RawTransactionArgument<string>;
    baseIn: RawTransactionArgument<string>;
    quoteIn: RawTransactionArgument<string>;
    deepIn: RawTransactionArgument<string>;
    minOut: RawTransactionArgument<number | bigint>;
}
export interface SwapExactQuantityOptions {
    package?: string;
    arguments: SwapExactQuantityArguments | [
        self: RawTransactionArgument<string>,
        baseIn: RawTransactionArgument<string>,
        quoteIn: RawTransactionArgument<string>,
        deepIn: RawTransactionArgument<string>,
        minOut: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/** Swap exact quantity without needing a balance_manager. */
export declare function swapExactQuantity(options: SwapExactQuantityOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ModifyOrderArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
    orderId: RawTransactionArgument<number | bigint>;
    newQuantity: RawTransactionArgument<number | bigint>;
}
export interface ModifyOrderOptions {
    package?: string;
    arguments: ModifyOrderArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>,
        orderId: RawTransactionArgument<number | bigint>,
        newQuantity: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Modifies an order given order_id and new_quantity. New quantity must be less
 * than the original quantity and more than the filled quantity. Order must not
 * have already expired.
 */
export declare function modifyOrder(options: ModifyOrderOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CancelOrderArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
    orderId: RawTransactionArgument<number | bigint>;
}
export interface CancelOrderOptions {
    package?: string;
    arguments: CancelOrderArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>,
        orderId: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Cancel an order. The order must be owned by the balance_manager. The order is
 * removed from the book and the balance_manager's open orders. The
 * balance_manager's balance is updated with the order's remaining quantity. Order
 * canceled event is emitted.
 */
export declare function cancelOrder(options: CancelOrderOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CancelOrdersArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
    orderIds: RawTransactionArgument<number | bigint[]>;
}
export interface CancelOrdersOptions {
    package?: string;
    arguments: CancelOrdersArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>,
        orderIds: RawTransactionArgument<number | bigint[]>
    ];
    typeArguments: [string, string];
}
/**
 * Cancel multiple orders within a vector. The orders must be owned by the
 * balance_manager. The orders are removed from the book and the balance_manager's
 * open orders. Order canceled events are emitted. If any order fails to cancel, no
 * orders will be cancelled.
 */
export declare function cancelOrders(options: CancelOrdersOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CancelAllOrdersArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
}
export interface CancelAllOrdersOptions {
    package?: string;
    arguments: CancelAllOrdersArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/** Cancel all open orders placed by the balance manager in the pool. */
export declare function cancelAllOrders(options: CancelAllOrdersOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface WithdrawSettledAmountsArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
}
export interface WithdrawSettledAmountsOptions {
    package?: string;
    arguments: WithdrawSettledAmountsArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/** Withdraw settled amounts to the `balance_manager`. */
export declare function withdrawSettledAmounts(options: WithdrawSettledAmountsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface StakeArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
    amount: RawTransactionArgument<number | bigint>;
}
export interface StakeOptions {
    package?: string;
    arguments: StakeArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>,
        amount: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Stake DEEP tokens to the pool. The balance_manager must have enough DEEP tokens.
 * The balance_manager's data is updated with the staked amount.
 */
export declare function stake(options: StakeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UnstakeArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
}
export interface UnstakeOptions {
    package?: string;
    arguments: UnstakeArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/**
 * Unstake DEEP tokens from the pool. The balance_manager must have enough staked
 * DEEP tokens. The balance_manager's data is updated with the unstaked amount.
 * Balance is transferred to the balance_manager immediately.
 */
export declare function unstake(options: UnstakeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SubmitProposalArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
    takerFee: RawTransactionArgument<number | bigint>;
    makerFee: RawTransactionArgument<number | bigint>;
    stakeRequired: RawTransactionArgument<number | bigint>;
}
export interface SubmitProposalOptions {
    package?: string;
    arguments: SubmitProposalArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>,
        takerFee: RawTransactionArgument<number | bigint>,
        makerFee: RawTransactionArgument<number | bigint>,
        stakeRequired: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Submit a proposal to change the taker fee, maker fee, and stake required. The
 * balance_manager must have enough staked DEEP tokens to participate. Each
 * balance_manager can only submit one proposal per epoch. If the maximum proposal
 * is reached, the proposal with the lowest vote is removed. If the balance_manager
 * has less voting power than the lowest voted proposal, the proposal is not added.
 */
export declare function submitProposal(options: SubmitProposalOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface VoteArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
    proposalId: RawTransactionArgument<string>;
}
export interface VoteOptions {
    package?: string;
    arguments: VoteArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>,
        proposalId: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/**
 * Vote on a proposal. The balance_manager must have enough staked DEEP tokens to
 * participate. Full voting power of the balance_manager is used. Voting for a new
 * proposal will remove the vote from the previous proposal.
 */
export declare function vote(options: VoteOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ClaimRebatesArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
    tradeProof: RawTransactionArgument<string>;
}
export interface ClaimRebatesOptions {
    package?: string;
    arguments: ClaimRebatesArguments | [
        self: RawTransactionArgument<string>,
        balanceManager: RawTransactionArgument<string>,
        tradeProof: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/**
 * Claim the rewards for the balance_manager. The balance_manager must have rewards
 * to claim. The balance_manager's data is updated with the claimed rewards.
 */
export declare function claimRebates(options: ClaimRebatesOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface BorrowFlashloanBaseArguments {
    self: RawTransactionArgument<string>;
    baseAmount: RawTransactionArgument<number | bigint>;
}
export interface BorrowFlashloanBaseOptions {
    package?: string;
    arguments: BorrowFlashloanBaseArguments | [self: RawTransactionArgument<string>, baseAmount: RawTransactionArgument<number | bigint>];
    typeArguments: [string, string];
}
/**
 * Borrow base assets from the Pool. A hot potato is returned, forcing the borrower
 * to return the assets within the same transaction.
 */
export declare function borrowFlashloanBase(options: BorrowFlashloanBaseOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface BorrowFlashloanQuoteArguments {
    self: RawTransactionArgument<string>;
    quoteAmount: RawTransactionArgument<number | bigint>;
}
export interface BorrowFlashloanQuoteOptions {
    package?: string;
    arguments: BorrowFlashloanQuoteArguments | [self: RawTransactionArgument<string>, quoteAmount: RawTransactionArgument<number | bigint>];
    typeArguments: [string, string];
}
/**
 * Borrow quote assets from the Pool. A hot potato is returned, forcing the
 * borrower to return the assets within the same transaction.
 */
export declare function borrowFlashloanQuote(options: BorrowFlashloanQuoteOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ReturnFlashloanBaseArguments {
    self: RawTransactionArgument<string>;
    coin: RawTransactionArgument<string>;
    flashLoan: RawTransactionArgument<string>;
}
export interface ReturnFlashloanBaseOptions {
    package?: string;
    arguments: ReturnFlashloanBaseArguments | [
        self: RawTransactionArgument<string>,
        coin: RawTransactionArgument<string>,
        flashLoan: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/**
 * Return the flashloaned base assets to the Pool. FlashLoan object will only be
 * unwrapped if the assets are returned, otherwise the transaction will fail.
 */
export declare function returnFlashloanBase(options: ReturnFlashloanBaseOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ReturnFlashloanQuoteArguments {
    self: RawTransactionArgument<string>;
    coin: RawTransactionArgument<string>;
    flashLoan: RawTransactionArgument<string>;
}
export interface ReturnFlashloanQuoteOptions {
    package?: string;
    arguments: ReturnFlashloanQuoteArguments | [
        self: RawTransactionArgument<string>,
        coin: RawTransactionArgument<string>,
        flashLoan: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/**
 * Return the flashloaned quote assets to the Pool. FlashLoan object will only be
 * unwrapped if the assets are returned, otherwise the transaction will fail.
 */
export declare function returnFlashloanQuote(options: ReturnFlashloanQuoteOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AddDeepPricePointArguments {
    targetPool: RawTransactionArgument<string>;
    referencePool: RawTransactionArgument<string>;
}
export interface AddDeepPricePointOptions {
    package?: string;
    arguments: AddDeepPricePointArguments | [targetPool: RawTransactionArgument<string>, referencePool: RawTransactionArgument<string>];
    typeArguments: [string, string, string, string];
}
/**
 * Adds a price point along with a timestamp to the deep price. Allows for the
 * calculation of deep price per base asset.
 */
export declare function addDeepPricePoint(options: AddDeepPricePointOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface BurnDeepArguments {
    self: RawTransactionArgument<string>;
    treasuryCap: RawTransactionArgument<string>;
}
export interface BurnDeepOptions {
    package?: string;
    arguments: BurnDeepArguments | [self: RawTransactionArgument<string>, treasuryCap: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Burns DEEP tokens from the pool. Amount to burn is within history */
export declare function burnDeep(options: BurnDeepOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CreatePoolAdminArguments {
    registry: RawTransactionArgument<string>;
    tickSize: RawTransactionArgument<number | bigint>;
    lotSize: RawTransactionArgument<number | bigint>;
    minSize: RawTransactionArgument<number | bigint>;
    whitelistedPool: RawTransactionArgument<boolean>;
    stablePool: RawTransactionArgument<boolean>;
    Cap: RawTransactionArgument<string>;
}
export interface CreatePoolAdminOptions {
    package?: string;
    arguments: CreatePoolAdminArguments | [
        registry: RawTransactionArgument<string>,
        tickSize: RawTransactionArgument<number | bigint>,
        lotSize: RawTransactionArgument<number | bigint>,
        minSize: RawTransactionArgument<number | bigint>,
        whitelistedPool: RawTransactionArgument<boolean>,
        stablePool: RawTransactionArgument<boolean>,
        Cap: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/**
 * Create a new pool. The pool is registered in the registry. Checks are performed
 * to ensure the tick size, lot size, and min size are valid. Returns the id of the
 * pool created
 */
export declare function createPoolAdmin(options: CreatePoolAdminOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UnregisterPoolAdminArguments {
    self: RawTransactionArgument<string>;
    registry: RawTransactionArgument<string>;
    Cap: RawTransactionArgument<string>;
}
export interface UnregisterPoolAdminOptions {
    package?: string;
    arguments: UnregisterPoolAdminArguments | [
        self: RawTransactionArgument<string>,
        registry: RawTransactionArgument<string>,
        Cap: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/** Unregister a pool in case it needs to be redeployed. */
export declare function unregisterPoolAdmin(options: UnregisterPoolAdminOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UpdateAllowedVersionsArguments {
    self: RawTransactionArgument<string>;
    registry: RawTransactionArgument<string>;
    Cap: RawTransactionArgument<string>;
}
export interface UpdateAllowedVersionsOptions {
    package?: string;
    arguments: UpdateAllowedVersionsArguments | [
        self: RawTransactionArgument<string>,
        registry: RawTransactionArgument<string>,
        Cap: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/**
 * Takes the registry and updates the allowed version within pool Only admin can
 * update the allowed versions This function does not have version restrictions
 */
export declare function updateAllowedVersions(options: UpdateAllowedVersionsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UpdatePoolAllowedVersionsArguments {
    self: RawTransactionArgument<string>;
    registry: RawTransactionArgument<string>;
}
export interface UpdatePoolAllowedVersionsOptions {
    package?: string;
    arguments: UpdatePoolAllowedVersionsArguments | [self: RawTransactionArgument<string>, registry: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/**
 * Takes the registry and updates the allowed version within pool Permissionless
 * equivalent of `update_allowed_versions` This function does not have version
 * restrictions
 */
export declare function updatePoolAllowedVersions(options: UpdatePoolAllowedVersionsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AdjustTickSizeAdminArguments {
    self: RawTransactionArgument<string>;
    newTickSize: RawTransactionArgument<number | bigint>;
    Cap: RawTransactionArgument<string>;
}
export interface AdjustTickSizeAdminOptions {
    package?: string;
    arguments: AdjustTickSizeAdminArguments | [
        self: RawTransactionArgument<string>,
        newTickSize: RawTransactionArgument<number | bigint>,
        Cap: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/** Adjust the tick size of the pool. Only admin can adjust the tick size. */
export declare function adjustTickSizeAdmin(options: AdjustTickSizeAdminOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AdjustMinLotSizeAdminArguments {
    self: RawTransactionArgument<string>;
    newLotSize: RawTransactionArgument<number | bigint>;
    newMinSize: RawTransactionArgument<number | bigint>;
    Cap: RawTransactionArgument<string>;
}
export interface AdjustMinLotSizeAdminOptions {
    package?: string;
    arguments: AdjustMinLotSizeAdminArguments | [
        self: RawTransactionArgument<string>,
        newLotSize: RawTransactionArgument<number | bigint>,
        newMinSize: RawTransactionArgument<number | bigint>,
        Cap: RawTransactionArgument<string>
    ];
    typeArguments: [string, string];
}
/**
 * Adjust and lot size and min size of the pool. New lot size must be smaller than
 * current lot size. Only admin can adjust the min size and lot size.
 */
export declare function adjustMinLotSizeAdmin(options: AdjustMinLotSizeAdminOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AuthorizeAppArguments {
    self: RawTransactionArgument<string>;
    Cap: RawTransactionArgument<string>;
}
export interface AuthorizeAppOptions {
    package?: string;
    arguments: AuthorizeAppArguments | [self: RawTransactionArgument<string>, Cap: RawTransactionArgument<string>];
    typeArguments: [string, string, string];
}
/** Authorize an application to access protected features of Deepbook core. */
export declare function authorizeApp(options: AuthorizeAppOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface DeauthorizeAppArguments {
    self: RawTransactionArgument<string>;
    Cap: RawTransactionArgument<string>;
}
export interface DeauthorizeAppOptions {
    package?: string;
    arguments: DeauthorizeAppArguments | [self: RawTransactionArgument<string>, Cap: RawTransactionArgument<string>];
    typeArguments: [string, string, string];
}
/** Deauthorize an application by removing its authorization key. */
export declare function deauthorizeApp(options: DeauthorizeAppOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface EnableEwmaStateArguments {
    self: RawTransactionArgument<string>;
    Cap: RawTransactionArgument<string>;
    enable: RawTransactionArgument<boolean>;
}
export interface EnableEwmaStateOptions {
    package?: string;
    arguments: EnableEwmaStateArguments | [
        self: RawTransactionArgument<string>,
        Cap: RawTransactionArgument<string>,
        enable: RawTransactionArgument<boolean>
    ];
    typeArguments: [string, string];
}
/**
 * Enable the EWMA state for the pool. This allows the pool to use the EWMA state
 * for volatility calculations and additional taker fees.
 */
export declare function enableEwmaState(options: EnableEwmaStateOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetEwmaParamsArguments {
    self: RawTransactionArgument<string>;
    Cap: RawTransactionArgument<string>;
    alpha: RawTransactionArgument<number | bigint>;
    zScoreThreshold: RawTransactionArgument<number | bigint>;
    additionalTakerFee: RawTransactionArgument<number | bigint>;
}
export interface SetEwmaParamsOptions {
    package?: string;
    arguments: SetEwmaParamsArguments | [
        self: RawTransactionArgument<string>,
        Cap: RawTransactionArgument<string>,
        alpha: RawTransactionArgument<number | bigint>,
        zScoreThreshold: RawTransactionArgument<number | bigint>,
        additionalTakerFee: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/** Set the EWMA parameters for the pool. Only admin can set the parameters. */
export declare function setEwmaParams(options: SetEwmaParamsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UpdateMarginStatusArguments<A extends BcsType<any>> {
    self: RawTransactionArgument<string>;
    _: RawTransactionArgument<A>;
    enable: RawTransactionArgument<boolean>;
}
export interface UpdateMarginStatusOptions<A extends BcsType<any>> {
    package?: string;
    arguments: UpdateMarginStatusArguments<A> | [
        self: RawTransactionArgument<string>,
        _: RawTransactionArgument<A>,
        enable: RawTransactionArgument<boolean>
    ];
    typeArguments: [string, string, string];
}
export declare function updateMarginStatus<A extends BcsType<any>>(options: UpdateMarginStatusOptions<A>): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface WhitelistedArguments {
    self: RawTransactionArgument<string>;
}
export interface WhitelistedOptions {
    package?: string;
    arguments: WhitelistedArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Accessor to check if the pool is whitelisted. */
export declare function whitelisted(options: WhitelistedOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface StablePoolArguments {
    self: RawTransactionArgument<string>;
}
export interface StablePoolOptions {
    package?: string;
    arguments: StablePoolArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Accessor to check if the pool is a stablecoin pool. */
export declare function stablePool(options: StablePoolOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RegisteredPoolArguments {
    self: RawTransactionArgument<string>;
}
export interface RegisteredPoolOptions {
    package?: string;
    arguments: RegisteredPoolArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
export declare function registeredPool(options: RegisteredPoolOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetQuoteQuantityOutArguments {
    self: RawTransactionArgument<string>;
    baseQuantity: RawTransactionArgument<number | bigint>;
}
export interface GetQuoteQuantityOutOptions {
    package?: string;
    arguments: GetQuoteQuantityOutArguments | [self: RawTransactionArgument<string>, baseQuantity: RawTransactionArgument<number | bigint>];
    typeArguments: [string, string];
}
/**
 * Dry run to determine the quote quantity out for a given base quantity. Uses DEEP
 * token as fee.
 */
export declare function getQuoteQuantityOut(options: GetQuoteQuantityOutOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetBaseQuantityOutArguments {
    self: RawTransactionArgument<string>;
    quoteQuantity: RawTransactionArgument<number | bigint>;
}
export interface GetBaseQuantityOutOptions {
    package?: string;
    arguments: GetBaseQuantityOutArguments | [
        self: RawTransactionArgument<string>,
        quoteQuantity: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Dry run to determine the base quantity out for a given quote quantity. Uses DEEP
 * token as fee.
 */
export declare function getBaseQuantityOut(options: GetBaseQuantityOutOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetQuoteQuantityOutInputFeeArguments {
    self: RawTransactionArgument<string>;
    baseQuantity: RawTransactionArgument<number | bigint>;
}
export interface GetQuoteQuantityOutInputFeeOptions {
    package?: string;
    arguments: GetQuoteQuantityOutInputFeeArguments | [self: RawTransactionArgument<string>, baseQuantity: RawTransactionArgument<number | bigint>];
    typeArguments: [string, string];
}
/**
 * Dry run to determine the quote quantity out for a given base quantity. Uses
 * input token as fee.
 */
export declare function getQuoteQuantityOutInputFee(options: GetQuoteQuantityOutInputFeeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetBaseQuantityOutInputFeeArguments {
    self: RawTransactionArgument<string>;
    quoteQuantity: RawTransactionArgument<number | bigint>;
}
export interface GetBaseQuantityOutInputFeeOptions {
    package?: string;
    arguments: GetBaseQuantityOutInputFeeArguments | [
        self: RawTransactionArgument<string>,
        quoteQuantity: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Dry run to determine the base quantity out for a given quote quantity. Uses
 * input token as fee.
 */
export declare function getBaseQuantityOutInputFee(options: GetBaseQuantityOutInputFeeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetQuantityOutArguments {
    self: RawTransactionArgument<string>;
    baseQuantity: RawTransactionArgument<number | bigint>;
    quoteQuantity: RawTransactionArgument<number | bigint>;
}
export interface GetQuantityOutOptions {
    package?: string;
    arguments: GetQuantityOutArguments | [
        self: RawTransactionArgument<string>,
        baseQuantity: RawTransactionArgument<number | bigint>,
        quoteQuantity: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Dry run to determine the quantity out for a given base or quote quantity. Only
 * one out of base or quote quantity should be non-zero. Returns the
 * (base_quantity_out, quote_quantity_out, deep_quantity_required) Uses DEEP token
 * as fee.
 */
export declare function getQuantityOut(options: GetQuantityOutOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetQuantityOutInputFeeArguments {
    self: RawTransactionArgument<string>;
    baseQuantity: RawTransactionArgument<number | bigint>;
    quoteQuantity: RawTransactionArgument<number | bigint>;
}
export interface GetQuantityOutInputFeeOptions {
    package?: string;
    arguments: GetQuantityOutInputFeeArguments | [
        self: RawTransactionArgument<string>,
        baseQuantity: RawTransactionArgument<number | bigint>,
        quoteQuantity: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Dry run to determine the quantity out for a given base or quote quantity. Only
 * one out of base or quote quantity should be non-zero. Returns the
 * (base_quantity_out, quote_quantity_out, deep_quantity_required) Uses input token
 * as fee.
 */
export declare function getQuantityOutInputFee(options: GetQuantityOutInputFeeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface MidPriceArguments {
    self: RawTransactionArgument<string>;
}
export interface MidPriceOptions {
    package?: string;
    arguments: MidPriceArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Returns the mid price of the pool. */
export declare function midPrice(options: MidPriceOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AccountOpenOrdersArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
}
export interface AccountOpenOrdersOptions {
    package?: string;
    arguments: AccountOpenOrdersArguments | [self: RawTransactionArgument<string>, balanceManager: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Returns the order_id for all open order for the balance_manager in the pool. */
export declare function accountOpenOrders(options: AccountOpenOrdersOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetLevel2RangeArguments {
    self: RawTransactionArgument<string>;
    priceLow: RawTransactionArgument<number | bigint>;
    priceHigh: RawTransactionArgument<number | bigint>;
    isBid: RawTransactionArgument<boolean>;
}
export interface GetLevel2RangeOptions {
    package?: string;
    arguments: GetLevel2RangeArguments | [
        self: RawTransactionArgument<string>,
        priceLow: RawTransactionArgument<number | bigint>,
        priceHigh: RawTransactionArgument<number | bigint>,
        isBid: RawTransactionArgument<boolean>
    ];
    typeArguments: [string, string];
}
/**
 * Returns the (price_vec, quantity_vec) for the level2 order book. The price_low
 * and price_high are inclusive, all orders within the range are returned. is_bid
 * is true for bids and false for asks.
 */
export declare function getLevel2Range(options: GetLevel2RangeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetLevel2TicksFromMidArguments {
    self: RawTransactionArgument<string>;
    ticks: RawTransactionArgument<number | bigint>;
}
export interface GetLevel2TicksFromMidOptions {
    package?: string;
    arguments: GetLevel2TicksFromMidArguments | [self: RawTransactionArgument<string>, ticks: RawTransactionArgument<number | bigint>];
    typeArguments: [string, string];
}
/**
 * Returns the (price_vec, quantity_vec) for the level2 order book. Ticks are the
 * maximum number of ticks to return starting from best bid and best ask.
 * (bid_price, bid_quantity, ask_price, ask_quantity) are returned as 4 vectors.
 * The price vectors are sorted in descending order for bids and ascending order
 * for asks.
 */
export declare function getLevel2TicksFromMid(options: GetLevel2TicksFromMidOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface VaultBalancesArguments {
    self: RawTransactionArgument<string>;
}
export interface VaultBalancesOptions {
    package?: string;
    arguments: VaultBalancesArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Get all balances held in this pool. */
export declare function vaultBalances(options: VaultBalancesOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetPoolIdByAssetArguments {
    registry: RawTransactionArgument<string>;
}
export interface GetPoolIdByAssetOptions {
    package?: string;
    arguments: GetPoolIdByAssetArguments | [registry: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Get the ID of the pool given the asset types. */
export declare function getPoolIdByAsset(options: GetPoolIdByAssetOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetOrderArguments {
    self: RawTransactionArgument<string>;
    orderId: RawTransactionArgument<number | bigint>;
}
export interface GetOrderOptions {
    package?: string;
    arguments: GetOrderArguments | [self: RawTransactionArgument<string>, orderId: RawTransactionArgument<number | bigint>];
    typeArguments: [string, string];
}
/** Get the Order struct */
export declare function getOrder(options: GetOrderOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetOrdersArguments {
    self: RawTransactionArgument<string>;
    orderIds: RawTransactionArgument<number | bigint[]>;
}
export interface GetOrdersOptions {
    package?: string;
    arguments: GetOrdersArguments | [self: RawTransactionArgument<string>, orderIds: RawTransactionArgument<number | bigint[]>];
    typeArguments: [string, string];
}
/** Get multiple orders given a vector of order_ids. */
export declare function getOrders(options: GetOrdersOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetAccountOrderDetailsArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
}
export interface GetAccountOrderDetailsOptions {
    package?: string;
    arguments: GetAccountOrderDetailsArguments | [self: RawTransactionArgument<string>, balanceManager: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Return a copy of all orders that are in the book for this account. */
export declare function getAccountOrderDetails(options: GetAccountOrderDetailsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetOrderDeepPriceArguments {
    self: RawTransactionArgument<string>;
}
export interface GetOrderDeepPriceOptions {
    package?: string;
    arguments: GetOrderDeepPriceArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Return the DEEP price for the pool. */
export declare function getOrderDeepPrice(options: GetOrderDeepPriceOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetOrderDeepRequiredArguments {
    self: RawTransactionArgument<string>;
    baseQuantity: RawTransactionArgument<number | bigint>;
    price: RawTransactionArgument<number | bigint>;
}
export interface GetOrderDeepRequiredOptions {
    package?: string;
    arguments: GetOrderDeepRequiredArguments | [
        self: RawTransactionArgument<string>,
        baseQuantity: RawTransactionArgument<number | bigint>,
        price: RawTransactionArgument<number | bigint>
    ];
    typeArguments: [string, string];
}
/**
 * Returns the deep required for an order if it's taker or maker given quantity and
 * price Does not account for discounted taker fees Returns (deep_required_taker,
 * deep_required_maker)
 */
export declare function getOrderDeepRequired(options: GetOrderDeepRequiredOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface LockedBalanceArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
}
export interface LockedBalanceOptions {
    package?: string;
    arguments: LockedBalanceArguments | [self: RawTransactionArgument<string>, balanceManager: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/**
 * Returns the locked balance for the balance_manager in the pool Returns
 * (base_quantity, quote_quantity, deep_quantity)
 */
export declare function lockedBalance(options: LockedBalanceOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface PoolTradeParamsArguments {
    self: RawTransactionArgument<string>;
}
export interface PoolTradeParamsOptions {
    package?: string;
    arguments: PoolTradeParamsArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Returns the trade params for the pool. */
export declare function poolTradeParams(options: PoolTradeParamsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface PoolTradeParamsNextArguments {
    self: RawTransactionArgument<string>;
}
export interface PoolTradeParamsNextOptions {
    package?: string;
    arguments: PoolTradeParamsNextArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Returns the currently leading trade params for the next epoch for the pool */
export declare function poolTradeParamsNext(options: PoolTradeParamsNextOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface PoolBookParamsArguments {
    self: RawTransactionArgument<string>;
}
export interface PoolBookParamsOptions {
    package?: string;
    arguments: PoolBookParamsArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Returns the tick size, lot size, and min size for the pool. */
export declare function poolBookParams(options: PoolBookParamsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AccountArguments {
    self: RawTransactionArgument<string>;
    balanceManager: RawTransactionArgument<string>;
}
export interface AccountOptions {
    package?: string;
    arguments: AccountArguments | [self: RawTransactionArgument<string>, balanceManager: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
export declare function account(options: AccountOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface QuorumArguments {
    self: RawTransactionArgument<string>;
}
export interface QuorumOptions {
    package?: string;
    arguments: QuorumArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
/** Returns the quorum needed to pass proposal in the current epoch */
export declare function quorum(options: QuorumOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface IdArguments {
    self: RawTransactionArgument<string>;
}
export interface IdOptions {
    package?: string;
    arguments: IdArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
export declare function id(options: IdOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface MarginTradingEnabledArguments {
    self: RawTransactionArgument<string>;
}
export interface MarginTradingEnabledOptions {
    package?: string;
    arguments: MarginTradingEnabledArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string];
}
export declare function marginTradingEnabled(options: MarginTradingEnabledOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface IsAppAuthorizedArguments {
    self: RawTransactionArgument<string>;
}
export interface IsAppAuthorizedOptions {
    package?: string;
    arguments: IsAppAuthorizedArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string, string];
}
/**
 * Check if an application is authorized to access protected features of DeepBook
 * core.
 */
export declare function isAppAuthorized(options: IsAppAuthorizedOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AssertAppIsAuthorizedArguments {
    self: RawTransactionArgument<string>;
}
export interface AssertAppIsAuthorizedOptions {
    package?: string;
    arguments: AssertAppIsAuthorizedArguments | [self: RawTransactionArgument<string>];
    typeArguments: [string, string, string];
}
/**
 * Assert that an application is authorized to access protected features of
 * DeepBook core. Aborts with `EAppNotAuthorized` if not.
 */
export declare function assertAppIsAuthorized(options: AssertAppIsAuthorizedOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
