"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var pool_exports = {};
__export(pool_exports, {
  AppKey: () => AppKey,
  BookParamsUpdated: () => BookParamsUpdated,
  DeepBurned: () => DeepBurned,
  MarginTradingKey: () => MarginTradingKey,
  Pool: () => Pool,
  PoolCreated: () => PoolCreated,
  PoolInner: () => PoolInner,
  account: () => account,
  accountOpenOrders: () => accountOpenOrders,
  addDeepPricePoint: () => addDeepPricePoint,
  adjustMinLotSizeAdmin: () => adjustMinLotSizeAdmin,
  adjustTickSizeAdmin: () => adjustTickSizeAdmin,
  assertAppIsAuthorized: () => assertAppIsAuthorized,
  authorizeApp: () => authorizeApp,
  borrowFlashloanBase: () => borrowFlashloanBase,
  borrowFlashloanQuote: () => borrowFlashloanQuote,
  burnDeep: () => burnDeep,
  cancelAllOrders: () => cancelAllOrders,
  cancelOrder: () => cancelOrder,
  cancelOrders: () => cancelOrders,
  claimRebates: () => claimRebates,
  createPermissionlessPool: () => createPermissionlessPool,
  createPoolAdmin: () => createPoolAdmin,
  deauthorizeApp: () => deauthorizeApp,
  enableEwmaState: () => enableEwmaState,
  getAccountOrderDetails: () => getAccountOrderDetails,
  getBaseQuantityOut: () => getBaseQuantityOut,
  getBaseQuantityOutInputFee: () => getBaseQuantityOutInputFee,
  getLevel2Range: () => getLevel2Range,
  getLevel2TicksFromMid: () => getLevel2TicksFromMid,
  getOrder: () => getOrder,
  getOrderDeepPrice: () => getOrderDeepPrice,
  getOrderDeepRequired: () => getOrderDeepRequired,
  getOrders: () => getOrders,
  getPoolIdByAsset: () => getPoolIdByAsset,
  getQuantityOut: () => getQuantityOut,
  getQuantityOutInputFee: () => getQuantityOutInputFee,
  getQuoteQuantityOut: () => getQuoteQuantityOut,
  getQuoteQuantityOutInputFee: () => getQuoteQuantityOutInputFee,
  id: () => id,
  isAppAuthorized: () => isAppAuthorized,
  lockedBalance: () => lockedBalance,
  marginTradingEnabled: () => marginTradingEnabled,
  midPrice: () => midPrice,
  modifyOrder: () => modifyOrder,
  placeLimitOrder: () => placeLimitOrder,
  placeMarketOrder: () => placeMarketOrder,
  poolBookParams: () => poolBookParams,
  poolTradeParams: () => poolTradeParams,
  poolTradeParamsNext: () => poolTradeParamsNext,
  quorum: () => quorum,
  registeredPool: () => registeredPool,
  returnFlashloanBase: () => returnFlashloanBase,
  returnFlashloanQuote: () => returnFlashloanQuote,
  setEwmaParams: () => setEwmaParams,
  stablePool: () => stablePool,
  stake: () => stake,
  submitProposal: () => submitProposal,
  swapExactBaseForQuote: () => swapExactBaseForQuote,
  swapExactQuantity: () => swapExactQuantity,
  swapExactQuoteForBase: () => swapExactQuoteForBase,
  unregisterPoolAdmin: () => unregisterPoolAdmin,
  unstake: () => unstake,
  updateAllowedVersions: () => updateAllowedVersions,
  updateMarginStatus: () => updateMarginStatus,
  updatePoolAllowedVersions: () => updatePoolAllowedVersions,
  vaultBalances: () => vaultBalances,
  vote: () => vote,
  whitelisted: () => whitelisted,
  withdrawSettledAmounts: () => withdrawSettledAmounts
});
module.exports = __toCommonJS(pool_exports);
var import_utils = require("../utils/index.js");
var import_bcs = require("@mysten/sui/bcs");
var object = __toESM(require("./deps/sui/object.js"));
var versioned = __toESM(require("./deps/sui/versioned.js"));
var vec_set = __toESM(require("./deps/sui/vec_set.js"));
var book = __toESM(require("./book.js"));
var state = __toESM(require("./state.js"));
var vault = __toESM(require("./vault.js"));
var deep_price = __toESM(require("./deep_price.js"));
const $moduleName = "@deepbook/core::pool";
const Pool = new import_utils.MoveStruct({
  name: `${$moduleName}::Pool`,
  fields: {
    id: object.UID,
    inner: versioned.Versioned
  }
});
const PoolInner = new import_utils.MoveStruct({
  name: `${$moduleName}::PoolInner`,
  fields: {
    allowed_versions: vec_set.VecSet(import_bcs.bcs.u64()),
    pool_id: import_bcs.bcs.Address,
    book: book.Book,
    state: state.State,
    vault: vault.Vault,
    deep_price: deep_price.DeepPrice,
    registered_pool: import_bcs.bcs.bool()
  }
});
const PoolCreated = new import_utils.MoveStruct({
  name: `${$moduleName}::PoolCreated`,
  fields: {
    pool_id: import_bcs.bcs.Address,
    taker_fee: import_bcs.bcs.u64(),
    maker_fee: import_bcs.bcs.u64(),
    tick_size: import_bcs.bcs.u64(),
    lot_size: import_bcs.bcs.u64(),
    min_size: import_bcs.bcs.u64(),
    whitelisted_pool: import_bcs.bcs.bool(),
    treasury_address: import_bcs.bcs.Address
  }
});
const BookParamsUpdated = new import_utils.MoveStruct({
  name: `${$moduleName}::BookParamsUpdated`,
  fields: {
    pool_id: import_bcs.bcs.Address,
    tick_size: import_bcs.bcs.u64(),
    lot_size: import_bcs.bcs.u64(),
    min_size: import_bcs.bcs.u64(),
    timestamp: import_bcs.bcs.u64()
  }
});
const DeepBurned = new import_utils.MoveStruct({
  name: `${$moduleName}::DeepBurned`,
  fields: {
    pool_id: import_bcs.bcs.Address,
    deep_burned: import_bcs.bcs.u64()
  }
});
const AppKey = new import_utils.MoveStruct({
  name: `${$moduleName}::AppKey`,
  fields: {
    dummy_field: import_bcs.bcs.bool()
  }
});
const MarginTradingKey = new import_utils.MoveStruct({
  name: `${$moduleName}::MarginTradingKey`,
  fields: {
    dummy_field: import_bcs.bcs.bool()
  }
});
function createPermissionlessPool(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::registry::Registry`,
    "u64",
    "u64",
    "u64",
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::deep::DEEP>`
  ];
  const parameterNames = ["registry", "tickSize", "lotSize", "minSize", "creationFee"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "create_permissionless_pool",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function placeLimitOrder(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`,
    "u64",
    "u8",
    "u8",
    "u64",
    "u64",
    "bool",
    "bool",
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = [
    "self",
    "balanceManager",
    "tradeProof",
    "clientOrderId",
    "orderType",
    "selfMatchingOption",
    "price",
    "quantity",
    "isBid",
    "payWithDeep",
    "expireTimestamp",
    "clock"
  ];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "place_limit_order",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function placeMarketOrder(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`,
    "u64",
    "u8",
    "u64",
    "bool",
    "bool",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = [
    "self",
    "balanceManager",
    "tradeProof",
    "clientOrderId",
    "selfMatchingOption",
    "quantity",
    "isBid",
    "payWithDeep",
    "clock"
  ];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "place_market_order",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function swapExactBaseForQuote(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${options.typeArguments[0]}>`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::deep::DEEP>`,
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "baseIn", "deepIn", "minQuoteOut", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "swap_exact_base_for_quote",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function swapExactQuoteForBase(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${options.typeArguments[1]}>`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::deep::DEEP>`,
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "quoteIn", "deepIn", "minBaseOut", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "swap_exact_quote_for_base",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function swapExactQuantity(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${options.typeArguments[0]}>`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${options.typeArguments[1]}>`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::deep::DEEP>`,
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "baseIn", "quoteIn", "deepIn", "minOut", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "swap_exact_quantity",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function modifyOrder(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`,
    "u128",
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = [
    "self",
    "balanceManager",
    "tradeProof",
    "orderId",
    "newQuantity",
    "clock"
  ];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "modify_order",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function cancelOrder(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`,
    "u128",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "balanceManager", "tradeProof", "orderId", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "cancel_order",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function cancelOrders(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`,
    "vector<u128>",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "balanceManager", "tradeProof", "orderIds", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "cancel_orders",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function cancelAllOrders(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "balanceManager", "tradeProof", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "cancel_all_orders",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function withdrawSettledAmounts(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`
  ];
  const parameterNames = ["self", "balanceManager", "tradeProof"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "withdraw_settled_amounts",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function stake(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`,
    "u64"
  ];
  const parameterNames = ["self", "balanceManager", "tradeProof", "amount"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "stake",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function unstake(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`
  ];
  const parameterNames = ["self", "balanceManager", "tradeProof"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "unstake",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function submitProposal(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`,
    "u64",
    "u64",
    "u64"
  ];
  const parameterNames = [
    "self",
    "balanceManager",
    "tradeProof",
    "takerFee",
    "makerFee",
    "stakeRequired"
  ];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "submit_proposal",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function vote(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "balanceManager", "tradeProof", "proposalId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "vote",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function claimRebates(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`,
    `${packageAddress}::balance_manager::TradeProof`
  ];
  const parameterNames = ["self", "balanceManager", "tradeProof"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "claim_rebates",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function borrowFlashloanBase(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64"
  ];
  const parameterNames = ["self", "baseAmount"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "borrow_flashloan_base",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function borrowFlashloanQuote(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64"
  ];
  const parameterNames = ["self", "quoteAmount"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "borrow_flashloan_quote",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function returnFlashloanBase(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${options.typeArguments[0]}>`,
    `${packageAddress}::vault::FlashLoan`
  ];
  const parameterNames = ["self", "coin", "flashLoan"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "return_flashloan_base",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function returnFlashloanQuote(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${options.typeArguments[1]}>`,
    `${packageAddress}::vault::FlashLoan`
  ];
  const parameterNames = ["self", "coin", "flashLoan"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "return_flashloan_quote",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function addDeepPricePoint(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::pool::Pool<${options.typeArguments[2]}, ${options.typeArguments[3]}>`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["targetPool", "referencePool", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "add_deep_price_point",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function burnDeep(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::deep::ProtectedTreasury`
  ];
  const parameterNames = ["self", "treasuryCap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "burn_deep",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function createPoolAdmin(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::registry::Registry`,
    "u64",
    "u64",
    "u64",
    "bool",
    "bool",
    `${packageAddress}::registry::DeepbookAdminCap`
  ];
  const parameterNames = [
    "registry",
    "tickSize",
    "lotSize",
    "minSize",
    "whitelistedPool",
    "stablePool",
    "Cap"
  ];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "create_pool_admin",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function unregisterPoolAdmin(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::registry::Registry`,
    `${packageAddress}::registry::DeepbookAdminCap`
  ];
  const parameterNames = ["self", "registry", "Cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "unregister_pool_admin",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function updateAllowedVersions(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::registry::Registry`,
    `${packageAddress}::registry::DeepbookAdminCap`
  ];
  const parameterNames = ["self", "registry", "Cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "update_allowed_versions",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function updatePoolAllowedVersions(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::registry::Registry`
  ];
  const parameterNames = ["self", "registry"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "update_pool_allowed_versions",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function adjustTickSizeAdmin(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    `${packageAddress}::registry::DeepbookAdminCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "newTickSize", "Cap", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "adjust_tick_size_admin",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function adjustMinLotSizeAdmin(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "u64",
    `${packageAddress}::registry::DeepbookAdminCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "newLotSize", "newMinSize", "Cap", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "adjust_min_lot_size_admin",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function authorizeApp(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[1]}, ${options.typeArguments[2]}>`,
    `${packageAddress}::registry::DeepbookAdminCap`
  ];
  const parameterNames = ["self", "Cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "authorize_app",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function deauthorizeApp(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[1]}, ${options.typeArguments[2]}>`,
    `${packageAddress}::registry::DeepbookAdminCap`
  ];
  const parameterNames = ["self", "Cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "deauthorize_app",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function enableEwmaState(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::registry::DeepbookAdminCap`,
    "bool",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "Cap", "enable", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "enable_ewma_state",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function setEwmaParams(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::registry::DeepbookAdminCap`,
    "u64",
    "u64",
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "Cap", "alpha", "zScoreThreshold", "additionalTakerFee", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "set_ewma_params",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function updateMarginStatus(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[1]}, ${options.typeArguments[2]}>`,
    `${options.typeArguments[0]}`,
    "bool"
  ];
  const parameterNames = ["self", "_", "enable"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "update_margin_status",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function whitelisted(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "whitelisted",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function stablePool(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "stable_pool",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function registeredPool(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "registered_pool",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getQuoteQuantityOut(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "baseQuantity", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_quote_quantity_out",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getBaseQuantityOut(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "quoteQuantity", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_base_quantity_out",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getQuoteQuantityOutInputFee(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "baseQuantity", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_quote_quantity_out_input_fee",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getBaseQuantityOutInputFee(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "quoteQuantity", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_base_quantity_out_input_fee",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getQuantityOut(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "baseQuantity", "quoteQuantity", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_quantity_out",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getQuantityOutInputFee(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "baseQuantity", "quoteQuantity", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_quantity_out_input_fee",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function midPrice(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "mid_price",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function accountOpenOrders(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`
  ];
  const parameterNames = ["self", "balanceManager"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "account_open_orders",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getLevel2Range(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "u64",
    "bool",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "priceLow", "priceHigh", "isBid", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_level2_range",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getLevel2TicksFromMid(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "ticks", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_level2_ticks_from_mid",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function vaultBalances(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "vault_balances",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getPoolIdByAsset(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [`${packageAddress}::registry::Registry`];
  const parameterNames = ["registry"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_pool_id_by_asset",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getOrder(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u128"
  ];
  const parameterNames = ["self", "orderId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_order",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getOrders(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "vector<u128>"
  ];
  const parameterNames = ["self", "orderIds"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_orders",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getAccountOrderDetails(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`
  ];
  const parameterNames = ["self", "balanceManager"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_account_order_details",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getOrderDeepPrice(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_order_deep_price",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function getOrderDeepRequired(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    "u64",
    "u64"
  ];
  const parameterNames = ["self", "baseQuantity", "price"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "get_order_deep_required",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function lockedBalance(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`
  ];
  const parameterNames = ["self", "balanceManager"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "locked_balance",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function poolTradeParams(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "pool_trade_params",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function poolTradeParamsNext(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "pool_trade_params_next",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function poolBookParams(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "pool_book_params",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function account(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`,
    `${packageAddress}::balance_manager::BalanceManager`
  ];
  const parameterNames = ["self", "balanceManager"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "account",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function quorum(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "quorum",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function id(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "id",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function marginTradingEnabled(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[0]}, ${options.typeArguments[1]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "margin_trading_enabled",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function isAppAuthorized(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[1]}, ${options.typeArguments[2]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "is_app_authorized",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
function assertAppIsAuthorized(options) {
  const packageAddress = options.package ?? "@deepbook/core";
  const argumentsTypes = [
    `${packageAddress}::pool::Pool<${options.typeArguments[1]}, ${options.typeArguments[2]}>`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "pool",
    function: "assert_app_is_authorized",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
//# sourceMappingURL=pool.js.map
