"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var marginMaintainer_exports = {};
__export(marginMaintainer_exports, {
  MarginMaintainerContract: () => MarginMaintainerContract
});
module.exports = __toCommonJS(marginMaintainer_exports);
var import_config = require("../utils/config.js");
var _config, _MarginMaintainerContract_instances, marginMaintainerCap_fn;
class MarginMaintainerContract {
  /**
   * @param {DeepBookConfig} config Configuration for MarginMaintainerContract
   */
  constructor(config) {
    __privateAdd(this, _MarginMaintainerContract_instances);
    __privateAdd(this, _config);
    /**
     * @description Create a new margin pool
     * @param {string} coinKey The key to identify the coin
     * @param {TransactionArgument} poolConfig The configuration for the pool
     * @returns A function that takes a Transaction object
     */
    this.createMarginPool = (coinKey, poolConfig) => (tx) => {
      const coin = __privateGet(this, _config).getCoin(coinKey);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_pool::create_margin_pool`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          poolConfig,
          tx.object(__privateMethod(this, _MarginMaintainerContract_instances, marginMaintainerCap_fn).call(this)),
          tx.object.clock()
        ],
        typeArguments: [coin.type]
      });
    };
    /**
     * @description Create a new protocol config
     * @param {string} coinKey The key to identify the coin
     * @param {MarginPoolConfigParams} marginPoolConfig The configuration for the margin pool
     * @param {InterestConfigParams} interestConfig The configuration for the interest
     * @returns A function that takes a Transaction object
     */
    this.newProtocolConfig = (coinKey, marginPoolConfig, interestConfig) => (tx) => {
      const marginPoolConfigObject = this.newMarginPoolConfig(coinKey, marginPoolConfig)(tx);
      const interestConfigObject = this.newInterestConfig(interestConfig)(tx);
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::protocol_config::new_protocol_config`,
        arguments: [marginPoolConfigObject, interestConfigObject]
      });
    };
    /**
     * @description Create a new margin pool config
     * @param {string} coinKey The key to identify the coin
     * @param {MarginPoolConfigParams} marginPoolConfig The configuration for the margin pool
     * @returns A function that takes a Transaction object
     */
    this.newMarginPoolConfig = (coinKey, marginPoolConfig) => (tx) => {
      const coin = __privateGet(this, _config).getCoin(coinKey);
      const { supplyCap, maxUtilizationRate, referralSpread, minBorrow } = marginPoolConfig;
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::protocol_config::new_margin_pool_config`,
        arguments: [
          tx.pure.u64(supplyCap * coin.scalar),
          tx.pure.u64(maxUtilizationRate * import_config.FLOAT_SCALAR),
          tx.pure.u64(referralSpread * import_config.FLOAT_SCALAR),
          tx.pure.u64(Math.round(minBorrow * coin.scalar))
        ]
      });
    };
    /**
     * @description Create a new margin pool config with rate limit
     * @param {string} coinKey The key to identify the coin
     * @param {MarginPoolConfigWithRateLimitParams} marginPoolConfig The configuration for the margin pool with rate limit
     * @returns A function that takes a Transaction object
     */
    this.newMarginPoolConfigWithRateLimit = (coinKey, marginPoolConfig) => (tx) => {
      const coin = __privateGet(this, _config).getCoin(coinKey);
      const {
        supplyCap,
        maxUtilizationRate,
        referralSpread,
        minBorrow,
        rateLimitCapacity,
        rateLimitRefillRatePerMs,
        rateLimitEnabled
      } = marginPoolConfig;
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::protocol_config::new_margin_pool_config_with_rate_limit`,
        arguments: [
          tx.pure.u64(supplyCap * coin.scalar),
          tx.pure.u64(maxUtilizationRate * import_config.FLOAT_SCALAR),
          tx.pure.u64(referralSpread * import_config.FLOAT_SCALAR),
          tx.pure.u64(Math.round(minBorrow * coin.scalar)),
          tx.pure.u64(Math.round(rateLimitCapacity * coin.scalar)),
          tx.pure.u64(Math.round(rateLimitRefillRatePerMs * coin.scalar)),
          tx.pure.bool(rateLimitEnabled)
        ]
      });
    };
    /**
     * @description Create a new interest config
     * @param {InterestConfigParams} interestConfig The configuration for the interest
     * @returns A function that takes a Transaction object
     */
    this.newInterestConfig = (interestConfig) => (tx) => {
      const { baseRate, baseSlope, optimalUtilization, excessSlope } = interestConfig;
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::protocol_config::new_interest_config`,
        arguments: [
          tx.pure.u64(baseRate * import_config.FLOAT_SCALAR),
          tx.pure.u64(baseSlope * import_config.FLOAT_SCALAR),
          tx.pure.u64(optimalUtilization * import_config.FLOAT_SCALAR),
          tx.pure.u64(excessSlope * import_config.FLOAT_SCALAR)
        ]
      });
    };
    /**
     * @description Enable a deepbook pool for loan
     * @param {string} deepbookPoolKey The key to identify the deepbook pool
     * @param {string} coinKey The key to identify the margin pool
     * @param {TransactionObjectArgument} marginPoolCap The margin pool cap
     * @returns A function that takes a Transaction object
     */
    this.enableDeepbookPoolForLoan = (deepbookPoolKey, coinKey, marginPoolCap) => (tx) => {
      const deepbookPool = __privateGet(this, _config).getPool(deepbookPoolKey);
      const marginPool = __privateGet(this, _config).getMarginPool(coinKey);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_pool::enable_deepbook_pool_for_loan`,
        arguments: [
          tx.object(marginPool.address),
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.pure.id(deepbookPool.address),
          tx.object(marginPoolCap),
          tx.object.clock()
        ],
        typeArguments: [marginPool.type]
      });
    };
    /**
     * @description Disable a deepbook pool for loan
     * @param {string} deepbookPoolKey The key to identify the deepbook pool
     * @param {string} coinKey The key to identify the margin pool
     * @param {TransactionObjectArgument} marginPoolCap The margin pool cap
     * @returns A function that takes a Transaction object
     */
    this.disableDeepbookPoolForLoan = (deepbookPoolKey, coinKey, marginPoolCap) => (tx) => {
      const deepbookPool = __privateGet(this, _config).getPool(deepbookPoolKey);
      const marginPool = __privateGet(this, _config).getMarginPool(coinKey);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_pool::disable_deepbook_pool_for_loan`,
        arguments: [
          tx.object(marginPool.address),
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.pure.id(deepbookPool.address),
          tx.object(marginPoolCap),
          tx.object.clock()
        ],
        typeArguments: [marginPool.type]
      });
    };
    /**
     * @description Update the interest params
     * @param {string} coinKey The key to identify the margin pool
     * @param {TransactionObjectArgument} marginPoolCap The margin pool cap
     * @param {InterestConfigParams} interestConfig The configuration for the interest
     * @returns A function that takes a Transaction object
     */
    this.updateInterestParams = (coinKey, marginPoolCap, interestConfig) => (tx) => {
      const marginPool = __privateGet(this, _config).getMarginPool(coinKey);
      const interestConfigObject = this.newInterestConfig(interestConfig)(tx);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_pool::update_interest_params`,
        arguments: [
          tx.object(marginPool.address),
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          interestConfigObject,
          tx.object(marginPoolCap),
          tx.object.clock()
        ],
        typeArguments: [marginPool.type]
      });
    };
    /**
     * @description Update the margin pool config
     * @param {string} coinKey The key to identify the margin pool
     * @param {TransactionObjectArgument} marginPoolCap The margin pool cap
     * @param {MarginPoolConfigParams} marginPoolConfig The configuration for the margin pool
     * @returns A function that takes a Transaction object
     */
    this.updateMarginPoolConfig = (coinKey, marginPoolCap, marginPoolConfig) => (tx) => {
      const marginPool = __privateGet(this, _config).getMarginPool(coinKey);
      const marginPoolConfigObject = this.newMarginPoolConfig(coinKey, marginPoolConfig)(tx);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_pool::update_margin_pool_config`,
        arguments: [
          tx.object(marginPool.address),
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          marginPoolConfigObject,
          tx.object(marginPoolCap),
          tx.object.clock()
        ],
        typeArguments: [marginPool.type]
      });
    };
    __privateSet(this, _config, config);
  }
}
_config = new WeakMap();
_MarginMaintainerContract_instances = new WeakSet();
/**
 * @returns The admin capability required for admin operations
 * @throws Error if the admin capability is not set
 */
marginMaintainerCap_fn = function() {
  const marginMaintainerCap = __privateGet(this, _config).marginMaintainerCap;
  if (!marginMaintainerCap) {
    throw new Error("MARGIN_ADMIN_CAP environment variable not set");
  }
  return marginMaintainerCap;
};
//# sourceMappingURL=marginMaintainer.js.map
