var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _config, _MarginAdminContract_instances, marginAdminCap_fn;
import { FLOAT_SCALAR } from "../utils/config.js";
import { hexToBytes } from "@noble/hashes/utils";
class MarginAdminContract {
  /**
   * @param {DeepBookConfig} config Configuration for MarginAdminContract
   */
  constructor(config) {
    __privateAdd(this, _MarginAdminContract_instances);
    __privateAdd(this, _config);
    /**
     * @description Mint a maintainer cap
     * @returns A function that takes a Transaction object
     */
    this.mintMaintainerCap = () => (tx) => {
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::mint_maintainer_cap`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this)),
          tx.object.clock()
        ]
      });
    };
    /**
     * @description Revoke a maintainer cap
     * @returns A function that takes a Transaction object
     */
    this.revokeMaintainerCap = (maintainerCapId) => (tx) => {
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::revoke_maintainer_cap`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this)),
          tx.object(maintainerCapId),
          tx.object.clock()
        ]
      });
    };
    /**
     * @description Register a deepbook pool
     * @param {string} poolKey The key of the pool to be registered
     * @param {TransactionArgument} poolConfig The configuration of the pool
     * @returns A function that takes a Transaction object
     */
    this.registerDeepbookPool = (poolKey, poolConfig) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::register_deepbook_pool`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this)),
          tx.object(pool.address),
          poolConfig,
          tx.object.clock()
        ],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Enable a deepbook pool for margin trading
     * @param {string} poolKey The key of the pool to be enabled
     * @returns A function that takes a Transaction object
     */
    this.enableDeepbookPool = (poolKey) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::enable_deepbook_pool`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this)),
          tx.object(pool.address),
          tx.object.clock()
        ],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Disable a deepbook pool from margin trading
     * @param {string} poolKey The key of the pool to be disabled
     * @returns A function that takes a Transaction object
     */
    this.disableDeepbookPool = (poolKey) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::disable_deepbook_pool`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this)),
          tx.object(pool.address),
          tx.object.clock()
        ],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Update the risk parameters for a margin
     * @param {string} poolKey The key of the pool to be updated
     * @param {TransactionArgument} poolConfig The configuration of the pool
     * @returns A function that takes a Transaction object
     */
    this.updateRiskParams = (poolKey, poolConfig) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::update_risk_params`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this)),
          tx.object(pool.address),
          poolConfig,
          tx.object.clock()
        ],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Add the PythConfig to the margin registry
     * @param {Transaction} tx The transaction object
     * @param {TransactionArgument} config The config to be added
     * @returns A function that takes a Transaction object
     */
    this.addConfig = (config) => (tx) => {
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::add_config`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this)),
          config
        ],
        typeArguments: [`${__privateGet(this, _config).MARGIN_PACKAGE_ID}::oracle::PythConfig`]
      });
    };
    /**
     * @description Remove the PythConfig from the margin registry
     * @param {Transaction} tx The transaction object
     * @returns A function that takes a Transaction object
     */
    this.removeConfig = () => (tx) => {
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::remove_config`,
        arguments: [tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID), tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this))],
        typeArguments: [`${__privateGet(this, _config).MARGIN_PACKAGE_ID}::oracle::PythConfig`]
      });
    };
    /**
     * @description Enable a specific version
     * @param {number} version The version to be enabled
     * @returns A function that takes a Transaction object
     */
    this.enableVersion = (version) => (tx) => {
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::enable_version`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.pure.u64(version),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this))
        ]
      });
    };
    /**
     * @description Disable a specific version
     * @param {number} version The version to be disabled
     * @returns A function that takes a Transaction object
     */
    this.disableVersion = (version) => (tx) => {
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::disable_version`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.pure.u64(version),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this))
        ]
      });
    };
    /**
     * @description Create a new pool config
     * @param {string} poolKey The key to identify the pool
     * @param {PoolConfigParams} poolConfigParams The parameters for the pool config
     * @returns A function that takes a Transaction object
     */
    this.newPoolConfig = (poolKey, poolConfigParams) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const {
        minWithdrawRiskRatio,
        minBorrowRiskRatio,
        liquidationRiskRatio,
        targetLiquidationRiskRatio,
        userLiquidationReward,
        poolLiquidationReward
      } = poolConfigParams;
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::new_pool_config`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.pure.u64(minWithdrawRiskRatio * FLOAT_SCALAR),
          tx.pure.u64(minBorrowRiskRatio * FLOAT_SCALAR),
          tx.pure.u64(liquidationRiskRatio * FLOAT_SCALAR),
          tx.pure.u64(targetLiquidationRiskRatio * FLOAT_SCALAR),
          tx.pure.u64(userLiquidationReward * FLOAT_SCALAR),
          tx.pure.u64(poolLiquidationReward * FLOAT_SCALAR)
        ],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Create a new pool config with leverage
     * @param {string} poolKey The key to identify the pool
     * @param {number} leverage The leverage for the pool
     * @returns A function that takes a Transaction object
     */
    this.newPoolConfigWithLeverage = (poolKey, leverage) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::new_pool_config_with_leverage`,
        arguments: [tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID), tx.pure.u64(leverage * FLOAT_SCALAR)],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Create a new coin type data
     * @param {string} coinKey The key to identify the coin
     * @param {number} maxConfBps The maximum confidence interval in basis points
     * @param {number} maxEwmaDifferenceBps The maximum EWMA difference in basis points
     * @returns A function that takes a Transaction object
     */
    this.newCoinTypeData = (coinKey, maxConfBps, maxEwmaDifferenceBps) => (tx) => {
      const coin = __privateGet(this, _config).getCoin(coinKey);
      if (!coin.feed) {
        throw new Error("Coin feed not found");
      }
      const priceFeedInput = new Uint8Array(
        hexToBytes(coin["feed"].startsWith("0x") ? coin.feed.slice(2) : coin["feed"])
      );
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::oracle::new_coin_type_data_from_currency`,
        arguments: [
          tx.object(coin.currencyId),
          tx.pure.vector("u8", priceFeedInput),
          tx.pure.u64(maxConfBps),
          tx.pure.u64(maxEwmaDifferenceBps)
        ],
        typeArguments: [coin.type]
      });
    };
    /**
     * @description Create a new Pyth config
     * @param {Array<{coinKey: string, maxConfBps: number, maxEwmaDifferenceBps: number}>} coinSetups The coins with their oracle config to be added to the Pyth config
     * @param {number} maxAgeSeconds The max age in seconds for the Pyth config
     * @returns A function that takes a Transaction object
     */
    this.newPythConfig = (coinSetups, maxAgeSeconds) => (tx) => {
      const coinTypeDataList = [];
      for (const setup of coinSetups) {
        coinTypeDataList.push(
          this.newCoinTypeData(setup.coinKey, setup.maxConfBps, setup.maxEwmaDifferenceBps)(tx)
        );
      }
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::oracle::new_pyth_config`,
        arguments: [
          tx.makeMoveVec({
            elements: coinTypeDataList,
            type: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::oracle::CoinTypeData`
          }),
          tx.pure.u64(maxAgeSeconds)
        ]
      });
    };
    /**
     * @description Mint a pause cap
     * @returns A function that takes a Transaction object
     */
    this.mintPauseCap = () => (tx) => {
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::mint_pause_cap`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this)),
          tx.object.clock()
        ]
      });
    };
    /**
     * @description Revoke a pause cap
     * @param {string} pauseCapId The ID of the pause cap to revoke
     * @returns A function that takes a Transaction object
     */
    this.revokePauseCap = (pauseCapId) => (tx) => {
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::revoke_pause_cap`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this)),
          tx.object.clock(),
          tx.pure.id(pauseCapId)
        ]
      });
    };
    /**
     * @description Disable a version using pause cap
     * @param {number} version The version to disable
     * @param {string} pauseCapId The ID of the pause cap
     * @returns A function that takes a Transaction object
     */
    this.disableVersionPauseCap = (version, pauseCapId) => (tx) => {
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_registry::disable_version_pause_cap`,
        arguments: [
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.pure.u64(version),
          tx.object(pauseCapId)
        ]
      });
    };
    /**
     * @description Withdraw the default referral fees (admin only)
     * The default referral at 0x0 doesn't have a SupplyReferral object
     * @param {string} coinKey The key to identify the margin pool
     * @returns A function that takes a Transaction object and returns a Coin<Asset>
     */
    this.adminWithdrawDefaultReferralFees = (coinKey) => (tx) => {
      const coin = __privateGet(this, _config).getCoin(coinKey);
      const marginPool = __privateGet(this, _config).getMarginPool(coinKey);
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_pool::admin_withdraw_default_referral_fees`,
        arguments: [
          tx.object(marginPool.address),
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(__privateMethod(this, _MarginAdminContract_instances, marginAdminCap_fn).call(this))
        ],
        typeArguments: [coin.type]
      });
    };
    __privateSet(this, _config, config);
  }
}
_config = new WeakMap();
_MarginAdminContract_instances = new WeakSet();
/**
 * @returns The admin capability required for admin operations
 * @throws Error if the admin capability is not set
 */
marginAdminCap_fn = function() {
  const marginAdminCap = __privateGet(this, _config).marginAdminCap;
  if (!marginAdminCap) {
    throw new Error("MARGIN_ADMIN_CAP environment variable not set");
  }
  return marginAdminCap;
};
export {
  MarginAdminContract
};
//# sourceMappingURL=marginAdmin.js.map
