var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _config;
import { OrderType, SelfMatchingOptions } from "../types/index.js";
import { MAX_TIMESTAMP, FLOAT_SCALAR } from "../utils/config.js";
class MarginTPSLContract {
  /**
   * @param {DeepBookConfig} config Configuration for MarginTPSLContract
   */
  constructor(config) {
    __privateAdd(this, _config);
    // === Helper Functions ===
    /**
     * @description Create a new condition for a conditional order
     * @param {string} poolKey The key to identify the pool
     * @param {boolean} triggerBelowPrice Whether to trigger when price is below trigger price
     * @param {number} triggerPrice The price at which to trigger the order
     * @returns A function that takes a Transaction object
     */
    this.newCondition = (poolKey, triggerBelowPrice, triggerPrice) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const inputPrice = Math.round(
        triggerPrice * FLOAT_SCALAR * quoteCoin.scalar / baseCoin.scalar
      );
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::tpsl::new_condition`,
        arguments: [tx.pure.bool(triggerBelowPrice), tx.pure.u64(inputPrice)]
      });
    };
    /**
     * @description Create a new pending limit order for use in conditional orders
     * @param {string} poolKey The key to identify the pool
     * @param {PendingLimitOrderParams} params Parameters for the pending limit order
     * @returns A function that takes a Transaction object
     */
    this.newPendingLimitOrder = (poolKey, params) => (tx) => {
      const {
        clientOrderId,
        orderType = OrderType.NO_RESTRICTION,
        selfMatchingOption = SelfMatchingOptions.SELF_MATCHING_ALLOWED,
        price,
        quantity,
        isBid,
        payWithDeep = true,
        expireTimestamp = MAX_TIMESTAMP
      } = params;
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const inputPrice = Math.round(price * FLOAT_SCALAR * quoteCoin.scalar / baseCoin.scalar);
      const inputQuantity = Math.round(quantity * baseCoin.scalar);
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::tpsl::new_pending_limit_order`,
        arguments: [
          tx.pure.u64(clientOrderId),
          tx.pure.u8(orderType),
          tx.pure.u8(selfMatchingOption),
          tx.pure.u64(inputPrice),
          tx.pure.u64(inputQuantity),
          tx.pure.bool(isBid),
          tx.pure.bool(payWithDeep),
          tx.pure.u64(expireTimestamp)
        ]
      });
    };
    /**
     * @description Create a new pending market order for use in conditional orders
     * @param {string} poolKey The key to identify the pool
     * @param {PendingMarketOrderParams} params Parameters for the pending market order
     * @returns A function that takes a Transaction object
     */
    this.newPendingMarketOrder = (poolKey, params) => (tx) => {
      const {
        clientOrderId,
        selfMatchingOption = SelfMatchingOptions.SELF_MATCHING_ALLOWED,
        quantity,
        isBid,
        payWithDeep = true
      } = params;
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const inputQuantity = Math.round(quantity * baseCoin.scalar);
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::tpsl::new_pending_market_order`,
        arguments: [
          tx.pure.u64(clientOrderId),
          tx.pure.u8(selfMatchingOption),
          tx.pure.u64(inputQuantity),
          tx.pure.bool(isBid),
          tx.pure.bool(payWithDeep)
        ]
      });
    };
    // === Public Functions ===
    /**
     * @description Add a conditional order (take profit or stop loss)
     * @param {AddConditionalOrderParams} params Parameters for adding the conditional order
     * @returns A function that takes a Transaction object
     */
    this.addConditionalOrder = (params) => (tx) => {
      const { marginManagerKey, conditionalOrderId, triggerBelowPrice, triggerPrice, pendingOrder } = params;
      const manager = __privateGet(this, _config).getMarginManager(marginManagerKey);
      const pool = __privateGet(this, _config).getPool(manager.poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const condition = this.newCondition(manager.poolKey, triggerBelowPrice, triggerPrice)(tx);
      const isLimitOrder = "price" in pendingOrder;
      const pending = isLimitOrder ? this.newPendingLimitOrder(manager.poolKey, pendingOrder)(tx) : this.newPendingMarketOrder(manager.poolKey, pendingOrder)(tx);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_manager::add_conditional_order`,
        arguments: [
          tx.object(manager.address),
          tx.object(pool.address),
          tx.object(baseCoin.priceInfoObjectId),
          tx.object(quoteCoin.priceInfoObjectId),
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.pure.u64(conditionalOrderId),
          condition,
          pending,
          tx.object.clock()
        ],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Cancel all conditional orders for a margin manager
     * @param {string} marginManagerKey The key to identify the margin manager
     * @returns A function that takes a Transaction object
     */
    this.cancelAllConditionalOrders = (marginManagerKey) => (tx) => {
      const manager = __privateGet(this, _config).getMarginManager(marginManagerKey);
      const pool = __privateGet(this, _config).getPool(manager.poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_manager::cancel_all_conditional_orders`,
        arguments: [tx.object(manager.address), tx.object.clock()],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Cancel a specific conditional order
     * @param {string} marginManagerKey The key to identify the margin manager
     * @param {string} conditionalOrderId The ID of the conditional order to cancel
     * @returns A function that takes a Transaction object
     */
    this.cancelConditionalOrder = (marginManagerKey, conditionalOrderId) => (tx) => {
      const manager = __privateGet(this, _config).getMarginManager(marginManagerKey);
      const pool = __privateGet(this, _config).getPool(manager.poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_manager::cancel_conditional_order`,
        arguments: [tx.object(manager.address), tx.pure.u64(conditionalOrderId), tx.object.clock()],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Execute conditional orders that have been triggered
     * This is a permissionless function that can be called by anyone
     * @param {string} marginManagerKey The key to identify the margin manager
     * @param {number} maxOrdersToExecute Maximum number of orders to execute in this call
     * @returns A function that takes a Transaction object
     */
    this.executeConditionalOrders = (marginManagerKey, maxOrdersToExecute) => (tx) => {
      const manager = __privateGet(this, _config).getMarginManager(marginManagerKey);
      const pool = __privateGet(this, _config).getPool(manager.poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_manager::execute_conditional_orders`,
        arguments: [
          tx.object(manager.address),
          tx.object(pool.address),
          tx.object(baseCoin.priceInfoObjectId),
          tx.object(quoteCoin.priceInfoObjectId),
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.pure.u64(maxOrdersToExecute),
          tx.object.clock()
        ],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    // === Read-Only Functions ===
    /**
     * @description Get all conditional order IDs for a margin manager
     * @param {string} poolKey The key to identify the pool
     * @param {string} marginManagerId The ID of the margin manager
     * @returns A function that takes a Transaction object
     */
    this.conditionalOrderIds = (poolKey, marginManagerId) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_manager::conditional_order_ids`,
        arguments: [tx.object(marginManagerId)],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Get a specific conditional order by ID
     * @param {string} poolKey The key to identify the pool
     * @param {string} marginManagerId The ID of the margin manager
     * @param {string} conditionalOrderId The ID of the conditional order
     * @returns A function that takes a Transaction object
     */
    this.conditionalOrder = (poolKey, marginManagerId, conditionalOrderId) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_manager::conditional_order`,
        arguments: [tx.object(marginManagerId), tx.pure.u64(conditionalOrderId)],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Get the lowest trigger price for trigger_above orders
     * Returns constants::max_u64() if there are no trigger_above orders
     * @param {string} poolKey The key to identify the pool
     * @param {string} marginManagerId The ID of the margin manager
     * @returns A function that takes a Transaction object
     */
    this.lowestTriggerAbovePrice = (poolKey, marginManagerId) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_manager::lowest_trigger_above_price`,
        arguments: [tx.object(marginManagerId)],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Get the highest trigger price for trigger_below orders
     * Returns 0 if there are no trigger_below orders
     * @param {string} poolKey The key to identify the pool
     * @param {string} marginManagerId The ID of the margin manager
     * @returns A function that takes a Transaction object
     */
    this.highestTriggerBelowPrice = (poolKey, marginManagerId) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      return tx.moveCall({
        target: `${__privateGet(this, _config).MARGIN_PACKAGE_ID}::margin_manager::highest_trigger_below_price`,
        arguments: [tx.object(marginManagerId)],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    __privateSet(this, _config, config);
  }
}
_config = new WeakMap();
export {
  MarginTPSLContract
};
//# sourceMappingURL=marginTPSL.js.map
