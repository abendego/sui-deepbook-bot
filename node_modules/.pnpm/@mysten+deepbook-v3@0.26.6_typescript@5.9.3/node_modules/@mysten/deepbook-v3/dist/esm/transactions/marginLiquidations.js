var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _config;
import { coinWithBalance } from "@mysten/sui/transactions";
class MarginLiquidationsContract {
  /**
   * @param {DeepBookConfig} config Configuration for MarginLiquidationsContract
   */
  constructor(config) {
    __privateAdd(this, _config);
    /**
     * @description Create a new liquidation vault
     * @param {string} liquidationAdminCap The liquidation admin cap object ID
     * @returns A function that takes a Transaction object
     */
    this.createLiquidationVault = (liquidationAdminCap) => (tx) => {
      tx.moveCall({
        target: `${__privateGet(this, _config).LIQUIDATION_PACKAGE_ID}::liquidation_vault::create_liquidation_vault`,
        arguments: [tx.object(liquidationAdminCap)]
      });
    };
    /**
     * @description Deposit coins into a liquidation vault
     * @param {string} vaultId The liquidation vault object ID
     * @param {string} liquidationAdminCap The liquidation admin cap object ID
     * @param {string} coinKey The key to identify the coin type
     * @param {number} amount The amount to deposit
     * @returns A function that takes a Transaction object
     */
    this.deposit = (vaultId, liquidationAdminCap, coinKey, amount) => (tx) => {
      const coin = __privateGet(this, _config).getCoin(coinKey);
      const depositCoin = coinWithBalance({
        type: coin.type,
        balance: amount * coin.scalar
      });
      tx.moveCall({
        target: `${__privateGet(this, _config).LIQUIDATION_PACKAGE_ID}::liquidation_vault::deposit`,
        arguments: [tx.object(vaultId), tx.object(liquidationAdminCap), depositCoin],
        typeArguments: [coin.type]
      });
    };
    /**
     * @description Withdraw coins from a liquidation vault
     * @param {string} vaultId The liquidation vault object ID
     * @param {string} liquidationAdminCap The liquidation admin cap object ID
     * @param {string} coinKey The key to identify the coin type
     * @param {number} amount The amount to withdraw
     * @returns A function that takes a Transaction object and returns the withdrawn coin
     */
    this.withdraw = (vaultId, liquidationAdminCap, coinKey, amount) => (tx) => {
      const coin = __privateGet(this, _config).getCoin(coinKey);
      return tx.moveCall({
        target: `${__privateGet(this, _config).LIQUIDATION_PACKAGE_ID}::liquidation_vault::withdraw`,
        arguments: [
          tx.object(vaultId),
          tx.object(liquidationAdminCap),
          tx.pure.u64(amount * coin.scalar)
        ],
        typeArguments: [coin.type]
      });
    };
    /**
     * @description Liquidate a margin manager by repaying base debt
     * @param {string} vaultId The liquidation vault object ID
     * @param {string} managerAddress The margin manager address to liquidate
     * @param {string} poolKey The key to identify the pool
     * @param {number} [repayAmount] The amount to repay (in base asset units), or undefined for full liquidation
     * @returns A function that takes a Transaction object
     */
    this.liquidateBase = (vaultId, managerAddress, poolKey, repayAmount) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const baseMarginPool = __privateGet(this, _config).getMarginPool(pool.baseCoin);
      const quoteMarginPool = __privateGet(this, _config).getMarginPool(pool.quoteCoin);
      const repayAmountArg = repayAmount !== void 0 ? tx.pure.option("u64", BigInt(Math.floor(repayAmount * baseCoin.scalar))) : tx.pure.option("u64", null);
      tx.moveCall({
        target: `${__privateGet(this, _config).LIQUIDATION_PACKAGE_ID}::liquidation_vault::liquidate_base`,
        arguments: [
          tx.object(vaultId),
          tx.object(managerAddress),
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(baseCoin.priceInfoObjectId),
          tx.object(quoteCoin.priceInfoObjectId),
          tx.object(baseMarginPool.address),
          tx.object(quoteMarginPool.address),
          tx.object(pool.address),
          repayAmountArg,
          tx.object.clock()
        ],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    /**
     * @description Liquidate a margin manager by repaying quote debt
     * @param {string} vaultId The liquidation vault object ID
     * @param {string} managerAddress The margin manager address to liquidate
     * @param {string} poolKey The key to identify the pool
     * @param {number} [repayAmount] The amount to repay (in quote asset units), or undefined for full liquidation
     * @returns A function that takes a Transaction object
     */
    this.liquidateQuote = (vaultId, managerAddress, poolKey, repayAmount) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const baseMarginPool = __privateGet(this, _config).getMarginPool(pool.baseCoin);
      const quoteMarginPool = __privateGet(this, _config).getMarginPool(pool.quoteCoin);
      const repayAmountArg = repayAmount !== void 0 ? tx.pure.option("u64", BigInt(Math.floor(repayAmount * quoteCoin.scalar))) : tx.pure.option("u64", null);
      tx.moveCall({
        target: `${__privateGet(this, _config).LIQUIDATION_PACKAGE_ID}::liquidation_vault::liquidate_quote`,
        arguments: [
          tx.object(vaultId),
          tx.object(managerAddress),
          tx.object(__privateGet(this, _config).MARGIN_REGISTRY_ID),
          tx.object(baseCoin.priceInfoObjectId),
          tx.object(quoteCoin.priceInfoObjectId),
          tx.object(baseMarginPool.address),
          tx.object(quoteMarginPool.address),
          tx.object(pool.address),
          repayAmountArg,
          tx.object.clock()
        ],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
    };
    // === Read-Only Functions ===
    /**
     * @description Get the balance of a specific coin type in the liquidation vault
     * @param {string} vaultId The liquidation vault object ID
     * @param {string} coinKey The key to identify the coin type
     * @returns A function that takes a Transaction object
     */
    this.balance = (vaultId, coinKey) => (tx) => {
      const coin = __privateGet(this, _config).getCoin(coinKey);
      return tx.moveCall({
        target: `${__privateGet(this, _config).LIQUIDATION_PACKAGE_ID}::liquidation_vault::balance`,
        arguments: [tx.object(vaultId)],
        typeArguments: [coin.type]
      });
    };
    __privateSet(this, _config, config);
  }
}
_config = new WeakMap();
export {
  MarginLiquidationsContract
};
//# sourceMappingURL=marginLiquidations.js.map
