{
  "version": 3,
  "sources": ["../../../../src/contracts/utils/index.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { BcsType, TypeTag } from '@mysten/sui/bcs';\nimport { bcs, TypeTagSerializer, BcsStruct, BcsEnum, BcsTuple } from '@mysten/sui/bcs';\nimport { normalizeSuiAddress } from '@mysten/sui/utils';\nimport type { TransactionArgument } from '@mysten/sui/transactions';\nimport { isArgument } from '@mysten/sui/transactions';\nimport { ValidationError, ErrorMessages } from '../../utils/errors.js';\n\nconst MOVE_STDLIB_ADDRESS = normalizeSuiAddress('0x1');\nconst SUI_FRAMEWORK_ADDRESS = normalizeSuiAddress('0x2');\nconst SUI_SYSTEM_ADDRESS = normalizeSuiAddress('0x3');\n\nexport type RawTransactionArgument<T> = T | TransactionArgument;\n\n/**\n * @description Get the BCS schema for a given type tag\n * @param {string | TypeTag} typeTag - The Move type tag to get the schema for\n * @returns {BcsType<any> | null} The BCS schema if found, null otherwise\n */\nexport function getPureBcsSchema(typeTag: string | TypeTag): BcsType<any> | null {\n\tconst parsedTag = typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag) : typeTag;\n\n\tif ('u8' in parsedTag) {\n\t\treturn bcs.U8;\n\t} else if ('u16' in parsedTag) {\n\t\treturn bcs.U16;\n\t} else if ('u32' in parsedTag) {\n\t\treturn bcs.U32;\n\t} else if ('u64' in parsedTag) {\n\t\treturn bcs.U64;\n\t} else if ('u128' in parsedTag) {\n\t\treturn bcs.U128;\n\t} else if ('u256' in parsedTag) {\n\t\treturn bcs.U256;\n\t} else if ('address' in parsedTag) {\n\t\treturn bcs.Address;\n\t} else if ('bool' in parsedTag) {\n\t\treturn bcs.Bool;\n\t} else if ('vector' in parsedTag) {\n\t\tconst type = getPureBcsSchema(parsedTag.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t} else if ('struct' in parsedTag) {\n\t\tconst structTag = parsedTag.struct;\n\t\tconst pkg = normalizeSuiAddress(parsedTag.struct.address);\n\n\t\tif (pkg === MOVE_STDLIB_ADDRESS) {\n\t\t\tif (\n\t\t\t\t(structTag.module === 'ascii' || structTag.module === 'string') &&\n\t\t\t\tstructTag.name === 'String'\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (structTag.module === 'option' && structTag.name === 'Option') {\n\t\t\t\tconst type = getPureBcsSchema(structTag.typeParams[0]!);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (pkg === SUI_FRAMEWORK_ADDRESS && structTag.module === 'Object' && structTag.name === 'ID') {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * @description Normalize Move function arguments to TransactionArguments\n * @param {unknown[] | object} args - The arguments to normalize\n * @param {string[]} argTypes - The expected Move type strings for each argument\n * @param {string[]} [parameterNames] - Optional parameter names when args is an object\n * @returns {TransactionArgument[]} Array of normalized transaction arguments\n * @throws {Error} If arguments are invalid or don't match expected types\n */\nexport function normalizeMoveArguments(\n\targs: unknown[] | object,\n\targTypes: string[],\n\tparameterNames?: string[],\n): TransactionArgument[] {\n\tconst argLen = Array.isArray(args) ? args.length : Object.keys(args).length;\n\tif (parameterNames && argLen !== parameterNames.length) {\n\t\tthrow new ValidationError(ErrorMessages.INVALID_ARGUMENT_COUNT(parameterNames.length, argLen));\n\t}\n\n\tconst normalizedArgs: TransactionArgument[] = [];\n\n\tlet index = 0;\n\tfor (const [i, argType] of argTypes.entries()) {\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::deny_list::DenyList`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.denyList());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::random::Random`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.random());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::clock::Clock`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.clock());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_SYSTEM_ADDRESS}::sui_system::SuiSystemState`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.system());\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet arg;\n\t\tif (Array.isArray(args)) {\n\t\t\tif (index >= args.length) {\n\t\t\t\tthrow new ValidationError(ErrorMessages.INVALID_ARGUMENT_COUNT(index + 1, args.length));\n\t\t\t}\n\t\t\targ = args[index];\n\t\t} else {\n\t\t\tif (!parameterNames) {\n\t\t\t\tthrow new ValidationError(`Expected arguments to be passed as an array`);\n\t\t\t}\n\t\t\tconst name = parameterNames[index];\n\t\t\targ = args[name as keyof typeof args];\n\n\t\t\tif (arg == null) {\n\t\t\t\tthrow new ValidationError(ErrorMessages.PARAMETER_REQUIRED(name));\n\t\t\t}\n\t\t}\n\n\t\tindex += 1;\n\n\t\tif (typeof arg === 'function' || isArgument(arg)) {\n\t\t\tnormalizedArgs.push(arg as TransactionArgument);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst type = argTypes[i]!;\n\t\tconst bcsType = getPureBcsSchema(type);\n\n\t\tif (bcsType) {\n\t\t\tconst bytes = bcsType.serialize(arg as never);\n\t\t\tnormalizedArgs.push((tx) => tx.pure(bytes));\n\t\t\tcontinue;\n\t\t} else if (typeof arg === 'string') {\n\t\t\tnormalizedArgs.push((tx) => tx.object(arg));\n\t\t\tcontinue;\n\t\t}\n\n\t\tthrow new ValidationError(ErrorMessages.INVALID_ARGUMENT(stringify(arg) as string, type));\n\t}\n\n\treturn normalizedArgs;\n}\n\nexport class MoveStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsStruct<T, Name> {}\n\nexport class MoveEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string,\n> extends BcsEnum<T, Name> {}\n\nexport class MoveTuple<\n\tT extends readonly BcsType<any>[],\n\tconst Name extends string,\n> extends BcsTuple<T, Name> {}\n\n/**\n * @description Convert a value to string representation for error messages\n * @param {unknown} val - The value to stringify\n * @returns {unknown} String representation of the value\n * @private\n */\nfunction stringify(val: unknown): unknown {\n\tif (typeof val === 'object') {\n\t\treturn JSON.stringify(val, (val: unknown) => val);\n\t}\n\tif (typeof val === 'bigint') {\n\t\treturn val.toString();\n\t}\n\n\treturn val;\n}\n"],
  "mappings": "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",
  "names": ["val"]
}
