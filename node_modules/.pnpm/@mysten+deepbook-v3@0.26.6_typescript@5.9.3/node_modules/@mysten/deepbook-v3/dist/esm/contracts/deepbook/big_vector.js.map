{
  "version": 3,
  "sources": ["../../../../src/contracts/deepbook/big_vector.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * BigVector is an arbitrary sized vector-like data structure, implemented using an\n * on-chain B+ Tree to support almost constant time (log base max_fan_out) random\n * access, insertion and removal.\n *\n * Iteration is supported by exposing access to leaf nodes (slices). Finding the\n * initial slice can be done in almost constant time, and subsequently finding the\n * previous or next slice can also be done in constant time.\n *\n * Nodes in the B+ Tree are stored as individual dynamic fields hanging off the\n * `BigVector`.\n *\n * Note: The index type is `u128`, but the length is stored as `u64` because the\n * expectation is that indices are sparsely distributed.\n */\n\nimport { MoveStruct } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@deepbook/core::big_vector';\nexport const BigVector = new MoveStruct({\n\tname: `${$moduleName}::BigVector`,\n\tfields: {\n\t\tid: object.UID,\n\t\t/** How deep the tree structure is. */\n\t\tdepth: bcs.u8(),\n\t\t/**\n\t\t * Total number of elements that this vector contains, not including gaps in the\n\t\t * vector.\n\t\t */\n\t\tlength: bcs.u64(),\n\t\t/** Max size of leaf nodes (counted in number of elements, `E`). */\n\t\tmax_slice_size: bcs.u64(),\n\t\t/** Max size of interior nodes (counted in number of children). */\n\t\tmax_fan_out: bcs.u64(),\n\t\t/** ID of the tree's root structure. Value of `NO_SLICE` means there's no root. */\n\t\troot_id: bcs.u64(),\n\t\t/** The last node ID that was allocated. */\n\t\tlast_id: bcs.u64(),\n\t},\n});\n/**\n * A node in the B+ tree.\n *\n * If representing a leaf node, there are as many keys as values (such that\n * `keys[i]` is the key corresponding to `vals[i]`).\n *\n * A `Slice<u64>` can also represent an interior node, in which case `vals` contain\n * the IDs of its children and `keys` represent the partitions between children.\n * There will be one fewer key than value in this configuration.\n */\nexport function Slice<E extends BcsType<any>>(...typeParameters: [E]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::Slice<${typeParameters[0].name as E['name']}>`,\n\t\tfields: {\n\t\t\t/** Previous node in the intrusive doubly-linked list data structure. */\n\t\t\tprev: bcs.u64(),\n\t\t\t/** Next node in the intrusive doubly-linked list data structure. */\n\t\t\tnext: bcs.u64(),\n\t\t\tkeys: bcs.vector(bcs.u128()),\n\t\t\tvals: bcs.vector(typeParameters[0]),\n\t\t},\n\t});\n}\nexport const SliceRef = new MoveStruct({\n\tname: `${$moduleName}::SliceRef`,\n\tfields: {\n\t\tix: bcs.u64(),\n\t},\n});\n"],
  "mappings": "AAmBA,SAAS,kBAAkB;AAC3B,SAAS,WAAW;AAEpB,YAAY,YAAY;AACxB,MAAM,cAAc;AACb,MAAM,YAAY,IAAI,WAAW;AAAA,EACvC,MAAM,GAAG,WAAW;AAAA,EACpB,QAAQ;AAAA,IACP,IAAI,OAAO;AAAA;AAAA,IAEX,OAAO,IAAI,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA,IAKd,QAAQ,IAAI,IAAI;AAAA;AAAA,IAEhB,gBAAgB,IAAI,IAAI;AAAA;AAAA,IAExB,aAAa,IAAI,IAAI;AAAA;AAAA,IAErB,SAAS,IAAI,IAAI;AAAA;AAAA,IAEjB,SAAS,IAAI,IAAI;AAAA,EAClB;AACD,CAAC;AAWM,SAAS,SAAiC,gBAAqB;AACrE,SAAO,IAAI,WAAW;AAAA,IACrB,MAAM,GAAG,WAAW,WAAW,eAAe,CAAC,EAAE,IAAiB;AAAA,IAClE,QAAQ;AAAA;AAAA,MAEP,MAAM,IAAI,IAAI;AAAA;AAAA,MAEd,MAAM,IAAI,IAAI;AAAA,MACd,MAAM,IAAI,OAAO,IAAI,KAAK,CAAC;AAAA,MAC3B,MAAM,IAAI,OAAO,eAAe,CAAC,CAAC;AAAA,IACnC;AAAA,EACD,CAAC;AACF;AACO,MAAM,WAAW,IAAI,WAAW;AAAA,EACtC,MAAM,GAAG,WAAW;AAAA,EACpB,QAAQ;AAAA,IACP,IAAI,IAAI,IAAI;AAAA,EACb;AACD,CAAC;",
  "names": []
}
